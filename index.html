<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div id="header">
		<div id="properties">
			<div id="propertiesTitle"></div>
		</div><!--Using a comment to remove whitespace
		--><div id="overview">
			<div id="sceneOverview">
				<div id="currentScene">
				
				</div>
				
				<div id="allScenes">
				
				</div>
			</div>
			<div id="projectOverview">
				Project Overview
			</div>
			<div id="variableOverview">
				<div id="variables">
				
				</div>
				
				<div id="addVariables">
					<button onclick="addVariable()" id="addVariableButton">Add Variable</button>
					<textarea placeholder="Variable Name" id="variableName" type="text"></textarea>
				</div>
			</div>
			<div id="buttons">
				<button id="sceneButton" onclick="showScene()">Scene Overview</button>
				
				<button id="projectButton" onclick="showProject()">Project Overview</button>
				
				<button id="variablesButton" onclick="showVariables()">Global Variables</button>
			</div>
		</div>
	</div>
	<div id="main">
		<div id="viewport">
			<canvas id="overlayCanvas"></canvas>
			<canvas id="displayCanvas"></canvas>
			<div id="toolbar">
				<span id="toolbarLeftButtons">
					<button id="addButton">Add</button>
					<div id="dropdownAddButtons">
						<button class="addObjectButton" id="addRect" onclick="addObject('Rectangle')">Add Rectangle</button>
						<button class="addObjectButton" id="addCircle" onclick="addObject('Circle')">Add Circle</button>
						<button class="addObjectButton" id="addText" onclick="addObject('Text')">Add Text</button>
						<button class="addObjectButton" id="addImage" onclick="addObject('Image')">Add Image</button>
						
					</div>
					<button onclick="exportFile()" id="exportButton">Export</button>
					<label id="importUI" for="importButton">Import</label>
					<input type="file" onchange="importFile()" id="importButton">
				</span>
				
				<span id="toolbarCentreButtons">
					<button onclick="play()" id="play">Play</button>
					
					<button onclick="pause()" id="pause">Pause</button>
					
					<button onclick="stop()" id="stop">Stop</button>
				</span>
				
				<span id="coords">
					text
				</span>
				
				<!--<span id="toolbarRightButtons">
					
				</span>-->
			</div>
		</div><!--Using a comment to remove whitespace
		--><div id="textEditor">
			<textarea spellcheck="false" oninput="updateCode()" id="textArea"></textarea>
			<div id="textToolbar">
				<button onclick="detachTextEditor()" class="textButtons" id="detachButton">Detach</button>
				<button onclick="increaseFontSize()" class="textButtons" id="increaseSizeButton">Size +</button>
				<button onclick="decreaseFontSize()" class="textButtons" id="decreaseSizeButton">Size -</button>
				<select onchange="scriptChange()" id="scriptSelect"></select>
				<button onclick="createScript()" class="textButtons" id="addScriptButton">New script</button>
			</div>
		</div>
	</div>
	
	<div id="menu">
		<div id="imageBrowser">
			
		</div>
		
		<div id="importArea">
			<label id="imageButton" for="importImageButton">Import Image</label>
			<input type="file" onchange="importImage()" accept="image/*" id="importImageButton">
			
			<figure>
				<img id="imagePreview" src="noimage.png" alt="image preview">
				<figcaption>Image to be inserted</figcaption>
			</figure>
			
			<button onclick="loadImage()" id="useImageButton">Use Image</button>
		</div>
	</div>
	
	<script src="mylibrary.js"></script>
	<script>
	
		//"use script";
		
		//set up canvas
		var displayCanvas = document.getElementById("displayCanvas");
		var displayCtx = displayCanvas.getContext('2d');
		
		displayCanvas.width = parseFloat(window.getComputedStyle(displayCanvas).getPropertyValue('width'));
		displayCanvas.height = parseFloat(window.getComputedStyle(displayCanvas).getPropertyValue('height'));
							   				   
		var canvas = document.createElement('CANVAS');
		canvas.width = displayCanvas.width;
		canvas.height = displayCanvas.height;
		
		var overlayCanvas = document.getElementById("overlayCanvas");
		var overlayCtx = overlayCanvas.getContext('2d');
		
		overlayCanvas.style.width = canvas.width;
		overlayCanvas.style.height = canvas.height;
		
		overlayCanvas.width = canvas.width;
		overlayCanvas.height = canvas.height;

		var textArea = document.getElementById('textArea');
		textArea.value = `function start() {\n    \n}\n\nfunction update() {\n    this.x += 1;\n}`;
		
		var points = {};
		var squareSize;
		var pointsObject;
		
		var objectDragged;
		
		var changedScene;
		
		var objectPosX;
		var objectPosY;
		
		var objectSizeX;
		var objectSizeY;
		
		var zoomX = 1;
		var zoomY = 1;
		
		var backgroundColour = "#AAAAAA";
		
		var mouseDown = false;
		
		var running = false;
		var paused = false;
		
		var menuUp = false;
		
		var scenes = [];
		
		var globalVariables = [];
		var variableTimeout;
		
		var menusDisabled = false;
		
		var selectedImage;
		var previewImg = document.getElementById("imagePreview");
		
		var savedImages = [];
		
		
		
		//Command Pattern system
		
		class History {
			constructor() {
				this.undos = [];
				this.history = [];
			}
			
			undo() {
				if (this.history.length>0) {
					this.history[this.history.length-1].undo();
					this.undos.push(this.history.pop());
				}
			}
			
			redo() {
				if (this.undos.length>0) {
					this.undos[this.undos.length-1].run();
					this.history.push(this.undos.pop());
				}
			}
			
			run(command) {
				command.run();
				this.history.push(command);
				this.redos = [];
			}
			
			add(command) {
				this.history.push(command);
				this.redos = [];
			}
		}
		
		class ChangePositionCommand {
			constructor(object, origPosX, origPosY, newPosX, newPosY) {
				this.object = object;
				this.origPosX = origPosX;
				this.origPosY = origPosY;
				this.newPosX = newPosX;
				this.newPosY = newPosY;
			}
			
			undo() {
				this.object.x = this.origPosX;
				this.object.y = this.origPosY;
				drawScene();
				drawProperties();
			}
			
			run() {
				this.object.x = this.newPosX;
				this.object.y = this.newPosY;
				drawScene();
				drawProperties();
			}
		}
		
		class ChangePropertyCommand {
			constructor(object, property, origProp, newProp) {
				this.object = object;
				this.property = property;
				this.origProp = origProp;
				this.newProp = newProp;
			}
			
			undo() {
				this.object[this.property] = this.origProp;
				drawScene();
				//drawProperties();
			}
			
			run() {
				this.object[this.property] = this.newProp;
				drawScene();
				//drawProperties();
			}
		}
		
		class ChangeHierachyCommand {
			constructor(object, oldParent, newParent, element, oldParentEle, newParentEle) {
				this.object = object;
				this.oldParent = oldParent;
				this.newParent = newParent;
				this.element = element;
				this.oldParentEle = oldParentEle;
				this.newParentEle = newParentEle;
			}
			
			run() {
				this.newParent.add(this.object);
				this.newParentEle.appendChild(this.element);
				if (this.newParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
			
			undo() {
				this.oldParent.add(this.object);
				this.oldParentEle.appendChild(this.element);
				if (this.oldParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
		}
		
		class ChangeSizeCommand {
			constructor(object, oldWidth, oldHeight, newWidth, newHeight, oldX, oldY, newX, newY) {
				this.object = object;
				if (object.isRectangle === true) {
					this.propertyX = "width";
					this.propertyY = "height";
				}
				if (object.isCircle === true) {
					this.propertyX = "radius";
					this.propertyY = "radius";
				}
				if (object.isText === true) {
					this.propertyX = "fontSize";
					this.propertyY = "fontSize";
				}
				this.oldWidth = oldWidth;
				this.newWidth = newWidth;
				this.oldHeight = oldHeight;
				this.newHeight = newHeight;
				this.oldX = oldX;
				this.oldY = oldY;
				this.newX = newX;
				this.newY = newY;
			}
			
			run() {
				this.object[this.propertyX] = this.newWidth;
				this.object[this.propertyY] = this.newHeight;
				this.object.x = this.newX;
				this.object.y = this.newY;
				drawScene();
			}
			
			undo() {
				this.object[this.propertyX] = this.oldWidth;
				this.object[this.propertyY] = this.oldHeight;
				this.object.x = this.oldX;
				this.object.y = this.oldY;
				drawScene();
			}
		}
		
		MYLIB.setCanvas(canvas);
		
		MYLIB.runSpontaneously = false;
		
		var scene = new MYLIB.Scene();
		scene.addScript(`function update() {\n    MYLIB.clear();\n    this.draw();\n}`,
			'default');//default code to be run in the scene
		
		scenes.push(scene);
		
		var circ = new MYLIB.Circle(350, 100, 60);
		scene.add(circ);
		
		var rect2 = new MYLIB.Rectangle(50, 100, 100, 50);
		
		rect2.name = "fireRect";
		rect2.fill = true;
		rect2.fillColour = "#FF0000";
		
		var rect = new MYLIB.Rectangle(30, 300, 100, 50);
		rect.rotation = 1;
		scene.add(rect);
		rect.addScript(textArea.value);	
		addScriptOption(rect.scripts[0]);
		
		rect.addScript(`function start() {\n    this.fill = true;\n    this.fillColour = "green";\n}`);
		addScriptOption(rect.scripts[1]);
		//add that script
		
		var selectedObject = rect;
		
		scene.add(rect2);
		
		var rect3 = new MYLIB.Rectangle(10, 10, 50, 20);
		rect3.name = "testRecto";
		rect2.add(rect3);
		
		var text = new MYLIB.Text("Hello!", 500, 300);
		text.fontSize = 40;
		text.rotation = 0;
		scene.add(text);
		
		var image = new MYLIB.Image();
		scene.add(image);
		selectedObject = image;
		
		var activeScene = scene;
		
		var _history = new History();
		
		drawScene();
		
		//DEFINING PROPERTIES FOR EACH OBJECT
		
		var propertiesElement = document.getElementById('properties');
		
		function drawProperties() {
			
			updatePropertiesName();
						
			//remove all current stuff in properties
			
			var currProperties = document.getElementsByClassName("propertyColumn");
			var propLength = currProperties.length;
			for (var i=0;i<propLength;i++) {
				propertiesElement.removeChild(currProperties[0]);
			}
			
			//decide how many columns to have based on the selected object
			
			var numOfColumns = 3;
			
			//column 1 is x, y, size, rotation stuff
			
			//column 2 is fill/stroke and visiblity colour stuff
			
			//column 3 is name and misc
			
			//[name of property, size]
			
			var properties = [];
			
			class Property {
				constructor(name, size, column, type, displayName) {
					this.name = name;
					this.size = size;
					this.column = column;
					this.type = type;
					this.displayName = displayName;
					properties.push(this);
				}
			}
			
			new Property("x", 1, 1, "number", "x"), new Property("y", 1, 1, "number", "y"),
			new Property("width", 1, 1, "number", "width"), new Property("height", 1, 1, "number", "height"),
			new Property("radius", 1, 1, "number", "radius"), new Property("rotation", 1, 1, "number", "rotation"),
			new Property("string", 3, 1, "text", "string"), new Property("fontSize", 1, 1, "number", "Font Size"),
			new Property("fill", 3, 2, "boolean", "fill"), new Property("fillColour", 4, 2, "colour", "Fill Colour"),
			new Property("stroke", 3, 2, "boolean", "stroke"), new Property("strokeColour", 3, 2, "colour", "Stroke Colour"),
			new Property("strokeSize", 1, 2, "number", "Stroke Size"), new Property("visible", 3, 3, "boolean", "visible"),
			new Property("opacity", 2, 3, "number"), new Property("name", 10, 3, "text", "name");
			new Property("url", 4, 2, "image", "url");
			
			for (var j=0;j<numOfColumns;j++) {
				var column = document.createElement("DIV");
				column.className = "propertyColumn";
				column.style.width = 100 / numOfColumns + "%";
				
				for (var i=0;i<properties.length;i++) {
					if (selectedObject[properties[i].name] !== undefined && properties[i].column === j+1) {
						//work out what input is necessary
						
						let myinput = document.createElement("INPUT");
						
						myinput.className = "properties";
						
						myinput.property = properties[i].name;
						myinput.propertyType = properties[i].type;
						
						if (myinput.propertyType === "number" || myinput.propertyType === "text") {
							myinput.type = 'text';
						
							myinput.setAttribute("value", selectedObject[properties[i].name]);
							
							myinput.style.textAlign = "center";
							myinput.setAttribute("size", properties[i].size);
							
							myinput.addEventListener('input', updateProperties);
						}
						
						if (myinput.propertyType === "colour") {
							myinput.type = 'color';
							myinput.setAttribute("value", selectedObject[properties[i].name]);
							
							myinput.addEventListener('input', updateProperties);
						}
						
						if (myinput.propertyType === "boolean") {
							myinput.type = 'checkbox';
							
							if (selectedObject[properties[i].name] === true) {
								myinput.checked = true;
							}
							
							myinput.addEventListener('change', updateProperties);
						}
						
						if (myinput.propertyType === "image") {
							myinput.type = "button"
							
							if (selectedObject[properties[i].name] === "") {
								myinput.value = "No Image";
							} else {
								myinput.value = selectedObject[properties[i].name];
							}
							myinput.addEventListener('click', chooseImage);
							
							myinput.style.padding = properties[i].size + "px";
						}
						
						//can't use innerHTML directly on properties because it overwrites event listeners
						let text = document.createElement("SPAN");
						text.innerHTML += "<br>" + properties[i].name + ": ";
						column.appendChild(text);
						
						column.appendChild(myinput);
						
						
					}
				}
				propertiesElement.appendChild(column);
			}
			
		}
		drawProperties();
		
		function updatePropertiesName() {
			document.getElementById("propertiesTitle").innerHTML = "Properties for " + selectedObject.name;
		}
		
		function updateProperties(e) {
			switch(e.srcElement.propertyType) {
			
				case "number":
					if (!isNaN(e.srcElement.value) && e.srcElement.value !== "") {
						_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property,
							selectedObject[e.srcElement.property], parseFloat(e.srcElement.value)));
						//selectedObject[e.srcElement.property] = parseFloat(e.srcElement.value);
						//drawScene();
					}
					break;
					
				case "boolean":
					
					//parse as boolean
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.checked));
					//selectedObject[e.srcElement.property] = e.srcElement.checked;
					//drawScene();
					break;
				
				case "colour":
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					//drawScene();
					break;
				
				case "text":
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					//drawScene();
					if (e.srcElement.property === "name") {
						updatePropertiesName();
						drawSceneOverview();
					}
					break;
					
				default:
					console.warn("property type wrong?", e.srcElement.propertyType);
				
			}
		}
		
		//END OF PROPERTIES
		
		var elementDragged;
		
		function drawSceneOverview() {
			var sceneOverview = document.getElementById("sceneOverview");
			//do current scene first
			var currScene = document.getElementById("currentScene");
			
			
			
			//clear sceneoverview first
			while (currScene.children.length>0) {
				currScene.removeChild(currScene.children[0]);
			}
			
			currScene.addEventListener("dragover", function(e) {
				e.preventDefault();
			});
				
			currScene.addEventListener("drop", function(e) {
				e.preventDefault();
				
				if (changedScene === false) {
					_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
						activeScene, elementDragged, elementDragged.parentElement, currScene));
					/*elementDragged.parentElement.removeChild(elementDragged);
							
					currScene.appendChild(elementDragged);
					
					activeScene.add(elementDragged.object);
					
					//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
					elementDragged.style.marginLeft = "0px"
					drawScene();*/
				}
			});
			
			for (var i=0;i<activeScene.children.length;i++) {
				addElement(activeScene.children[i]);
				function addElement(object) {
				
					let DOMElement = document.createElement("SPAN");
					
					DOMElement.innerHTML = object.name + "<br>";
					
					DOMElement.className = "sceneChild";
					DOMElement.object = object;
					
					DOMElement.draggable = true;
					
					DOMElement.addEventListener("mouseover", function(e) {
						if (menusDisabled === false) {
							e.target.style.border = "dashed 1px black";
						}
					});
					
					DOMElement.addEventListener("mouseout", function(e) {
						e.target.style.border = "none";
					});
					
					DOMElement.addEventListener("click", function(e) {
						if (menusDisabled === false) {
							selectObject(e.target.object);
						}
					});
					
					DOMElement.addEventListener("dragstart", function(e) {
						if (menusDisabled === false) {
							elementDragged = e.target;
							if (e.target.style.border !== "1px solid black") {
								e.target.style.border = "double 1px black";
							}
							//console.log(e.target.innerHTML);
							changedScene = false;
						}
					});
					
					DOMElement.addEventListener("dragover", function(e) {
						e.preventDefault();
					});
					
					DOMElement.addEventListener("dragend", function(e) {
						DOMElement.style.border = "initial";
						//console.log(DOMElement.className);
					});
					
					DOMElement.addEventListener("drop", function(e) {
						e.preventDefault();
						changedScene = true;
						//prevent childing self and to child
						if (elementDragged !== e.target && !isRelated(elementDragged, e.target)) {
							//e.target.add(elementDragged);//fix this
							_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
								e.target.object, elementDragged, elementDragged.parentElement, e.target));
							/*elementDragged.parentElement.removeChild(elementDragged);
							
							e.target.appendChild(elementDragged);
							
							e.target.object.add(elementDragged.object);
							
							//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
							elementDragged.style.marginLeft = "26px"
							drawScene();*/
						}
					});
					
					addChildren(DOMElement);
					
					if (object.parent.constructor.name === "Scene") {
						currScene.appendChild(DOMElement);
					} else {
						return DOMElement;
					}
					
					function addChildren(element) {
						for (var i=0;i<element.object.children.length;i++) {
							var ele = addElement(element.object.children[i]);
							if (ele !== undefined) {
								ele.style.marginLeft = "26px";
								element.appendChild(ele);
							}
						}
					}
				}
			}
		}
		drawSceneOverview();
		
		function getVariableValue(e) {
			globalVariables[e.target.index][1] = e.target.value
		}
		
		function drawVariableOverview() {
			var variableElement = document.getElementById('variables');
			
			while (variableElement.children.length>0) {
				variableElement.removeChild(variableElement.children[0]);
			}
			
			for (var i=0;i<globalVariables.length;i++) {
				var temp = document.createElement("INPUT");
				temp.type = "text";
				temp.value = globalVariables[i][0];
				temp.style.width = temp.value.length * 20 + "px";
				temp.style.border = "1px solid black";
				
				variableElement.appendChild(temp);
				var equals = document.createElement("SPAN");
				equals.innerHTML = "=";
				equals.style.display = "inline-block";
				variableElement.appendChild(equals);
				
				var valueElement = document.createElement("INPUT");
				valueElement.style.display = "inline-block";
				valueElement.style.border = "1px solid black";
				valueElement.index = i;
				valueElement.addEventListener('input', getVariableValue);
				
				var maxWidth = parseFloat(window.getComputedStyle(variableElement).getPropertyValue('width'));
				var equalsWidth = parseFloat(window.getComputedStyle(equals).getPropertyValue('width'));
				
				valueElement.style.width = (maxWidth - temp.value.length * 20 - equalsWidth) + "px";
				variableElement.appendChild(valueElement);
				//console.log(temp, globalVariables);
			}
		}
		
		function addVariable() {
			var variableArea = document.getElementById('variableName');
			var variableName = variableArea.value
			var regexTest = RegExp('^[0-9]|\\s');
			
			if (window[variableName] || regexTest.test(variableName)) {
				
				variableArea.className = "failAnimation";
				if (variableTimeout) {
					clearTimeout(variableTimeout);
					
					var area = document.createElement("TEXTAREA");
					area.id = "variableName";
					area.className = "failAnimation";
					area.type = "text";
					area.placeholder = "Variable Name";
					area.value = variableName;
					variableArea.id="";
					var parentVarEle = document.getElementById('addVariables')
					parentVarEle.removeChild(variableArea);
					parentVarEle.appendChild(area);
					variableArea = area;
				}
				
				variableTimeout = setTimeout(function() {
					variableArea.className = "";
					variableTimeout = undefined;
				}, 2000);
				
				
			} else {
				//variable passed test
				globalVariables.push([variableName, ""]);
				variableArea.value = "";
				drawVariableOverview();
			}
		}
		
		function chooseImage(e) {
			if (e.target.property === "url") {
				drawImageMenu();
			}
		}
		
		function drawImageMenu() {
			var menu = document.getElementById("menu");
			menu.style.display = "block";
			disableMenus();
			drawBrowser();
		}
		
		function loadImage() {
			selectedObject.setImage(selectedImage[0]);
			selectedObject.url = selectedImage[1];
			var menu = document.getElementById("menu");
			menu.style.display = "none";
			enableMenus();
			if (selectedObject.loaded === true) {
				drawProperties();
				drawScene();
			} else {
				selectedObject.image.onload = function() {
					drawProperties();
					drawScene();
				}
			}
		}
		
		function importImage() {
			var imageEle = document.getElementById("importImageButton");
			
			var filereader = new FileReader();
			filereader.readAsDataURL(imageEle.files[0]);
			filereader.onload = function() {
				addImage(filereader.result, imageEle.files[0].name);
				drawBrowser();
			};
		}
		
		function addImage(img, fileName) {
			//img url, filename, index
			savedImages.push([img, fileName, savedImages.length]);
			selectedImage = savedImages[savedImages.length-1];
			
			previewImg.src = img;
		}
		
		function drawBrowser() {
			//each column is 128px across
			
			var browser = document.getElementById("imageBrowser");
			
			var maxWidth = parseFloat(window.getComputedStyle(browser).getPropertyValue('width'));
			
			
			while(browser.children.length>0) {
				browser.removeChild(browser.children[0]);
			}
			
			var tempRow = document.createElement("DIV");
			
			var i=0;
			
			for (var j=0;j<savedImages.length;j++) {
				//each box is 156 x 156
				//image preview is 128 x 128
				
				//create rows as long as there are images to load
				
				if ((j+1-i) * 156 > maxWidth) {
					console.log(i, j);
					i+=j;
					browser.appendChild(tempRow);
					tempRow = document.createElement("DIV");
				}
				
				var imageBox = document.createElement("FIGURE");
				imageBox.className = "imageBox";
				
				
				
				var image = document.createElement("IMG");
				image.className = "previewIcon";
				image.src = savedImages[j][0];
				image.fileName = savedImages[j][1];
				image.index = j;
				//image
				
				var caption = document.createElement("FIGCAPTION");
				caption.innerHTML = image.fileName;
				caption.className = "imageCaption";
				
				imageBox.appendChild(image);
				imageBox.appendChild(caption);
				tempRow.appendChild(imageBox);
				
				if (selectedImage) {
					if (selectedImage[2] === j) {
						imageBox.style.backgroundColor = "#0022FF";
						imageBox.children[1].style.color = "#FFFFFF";
					}
				}
				
				imageBox.addEventListener("click", function(e) {
					
					//clear selectedImage first
					
					if (selectedImage) {
						var index = selectedImage[2];
						
						var row = Math.floor(((index+1) * 156) / maxWidth);
						var ele = ((((index+1) * 156) % maxWidth) / 156) - 1;
						console.log(row, ele, index, browser);
						var element = browser.children[row].children[ele];
						element.style.backgroundColor = "#FFFFFF";
						element.children[1].style.color = "#000000";
					}
					
					this.style.backgroundColor = "#0022FF";
					this.children[1].style.color = "#FFFFFF";
					
					selectedImage = savedImages[this.children[0].index];
					
					previewImg.src = selectedImage[0];
				});
				
			}
			browser.appendChild(tempRow);
		}
		
		function selectObject(object) {
			selectedObject = object;
			
			drawProperties();
			drawScaleOverlay();
			
			var scriptElement = document.getElementById("scriptSelect");
			scriptElement.value = 0;
			
			//fix script
			while (scriptElement.children.length>0) {
				scriptElement.removeChild(scriptElement.children[0]);
			}
			
			for(var i=0;i<selectedObject.scripts.length;i++) {
				addScriptOption(selectedObject.scripts[i]);
			}
			scriptChange();
		}
		
		function addObject(type) {
			var temp = new MYLIB[type]();
			activeScene.add(temp);
			selectObject(temp);
			drawScene();
			drawSceneOverview();
		}
		
		function isRelated(element, element2) {
			for (var i=0;i<element.children.length;i++) {
				if (element2 === element.children[i]) {
					return true;
				}
			}
			for (var i=0;i<element2.children.length;i++) {
				if (element === element2.children[i]) {
					return true;
				}
			}
			return false;
		}
		
		function drawScene() {
			MYLIB.clear();
			activeScene.draw();
			
			displayCtx.fillStyle = backgroundColour;
			displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height);
			
			displayCtx.scale(zoomX, zoomY);
			
			//clear canvas
			displayCtx.clearRect(activeScene.x, activeScene.y, displayCanvas.width, displayCanvas.height);
			displayCtx.drawImage(canvas, 0, 0);
			
			displayCtx.setTransform(1, 0, 0, 1, 0, 0);
			drawScaleOverlay();
		}
		
		overlayCanvas.addEventListener('wheel', function(e) {
			zoomX = Math.max(0, zoomX - e.deltaY/1000);
			zoomY = Math.max(0, zoomX - e.deltaY/1000);
			drawScene();
		});

		textArea.addEventListener('keydown', function(e) {
			if (e.key === "Tab") {
				e.preventDefault();
				var caretStart = textArea.selectionStart;
				var caretEnd = textArea.selectionEnd;
				textArea.value = textArea.value.substring(0, caretStart) + "    " + textArea.value.substring(caretEnd);
				textArea.selectionEnd = textArea.selectionStart = caretStart + 4;
			}
		});
		
		document.addEventListener('keydown', function(e) {
			if (e.key === "z" && e.ctrlKey === true) {
				_history.undo();
			}
			if (e.key === "y" && e.ctrlKey === true) {
				_history.redo();
			}
		});
		
		document.addEventListener('mousedown', function(e) {
			mouseDown = true;
		});
		
		document.addEventListener('mouseup', function(e) {
			mouseDown = false;
			if (objectDragged === "object") {
				_history.add(new ChangePositionCommand(selectedObject, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
			}
			if (objectDragged !== true && objectDragged !== false) {
				if (selectedObject.isRectangle === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.width, 
						selectedObject.height, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
					
				}
				if (selectedObject.isCircle === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.radius,
						selectedObject.radius, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
				}
			}
			objectDragged = "";
			if (overlayCanvas.style.cursor === "-webkit-grabbing") {
				overlayCanvas.style.cursor = "-webkit-grab";
			}
		});
		
		document.addEventListener('dragend', function(e) {
			mouseDown = false;
			objectDragged = "";
		});
		
		overlayCanvas.addEventListener('mousedown', function(e) {
			//WORK ROTATION LATER
			if (menusDisabled === false) {
				var result = mouseOnOverlay(e.offsetX, e.offsetY);
				
				switch(result) {
					case true:
						objectDragged = "object";
						overlayCanvas.style.cursor = "-webkit-grabbing";
						break;
						
					case false:
						//using e.offsetX and e.offsetY
						var descendents = activeScene.getAllDescendents();
						var selectedSomething = false;
						for (var i=0;i<descendents.length;i++) {
							var dims = {x: descendents[i].x, y: descendents[i].y, rotation: descendents[i].rotation};
							var parentDims = descendents[i].addParentProperties();
							
							dims.x += parentDims.x;
							dims.y += parentDims.y;
							dims.rotation += parentDims.rotation;
							
							var selected = false;
							
							var objectWidth;
							var objectHeight;
							
							if (descendents[i].isRectangle === true || descendents[i].isImage === true ||
								descendents[i].isText === true) {
								if (descendents[i].isText === true) {
									objectWidth = descendents[i].getWidth();
									objectHeight = descendents[i].getHeight();
								}
							
								if (descendents[i].isRectangle === true || descendents[i].isImage === true) {
									objectWidth = descendents[i].width;
									objectHeight = descendents[i].height;
								}
								
								//rotate
								
								var newX = e.offsetX - (dims.x + objectWidth/2);
								var newY = e.offsetY - (dims.y + objectHeight/2);
								
								var newMouseX = newX * Math.cos(-dims.rotation) - newY * Math.sin(-dims.rotation);
								var newMouseY = newX * Math.sin(-dims.rotation) + newY * Math.cos(-dims.rotation);
								
								var mouseX = newMouseX + dims.x + objectWidth/2;
								var mouseY = newMouseY + dims.y + objectHeight/2;
								
								if (mouseX >= dims.x && mouseY >= dims.y &&
									mouseX <= dims.x + objectWidth &&
									mouseY <= dims.y + objectHeight) {
									
									selected = true;
								}
							}
									
							if (descendents[i].isCircle === true) {
								if (Math.hypot(Math.abs(e.offsetX - dims.x), Math.abs(e.offsetY - dims.y)) <= descendents[i].radius) {
									selected = true;
								}
							}
							
							if (selected === true) {
								selectObject(descendents[i]);
								objectDragged = "object";
								overlayCanvas.style.cursor = "-webkit-grabbing";
								selectedSomething = true;
								objectPosX = descendents[i].x;
								objectPosY = descendents[i].y;
							}
						}
						if (selectedSomething === false) {
							selectObject(activeScene);
							objectDragged = "object";
							overlayCanvas.style.cursor = "-webkit-grabbing";
							selectedSomething = true;
							objectPosX = activeScene;
							objectPosY = activeScene;
						}
						break;
						
					default:
						objectDragged = result;
						if (selectedObject.isRectangle === true || selectedObject.isImage === true) {
							objectSizeX = selectedObject.width;
							objectSizeY = selectedObject.height;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isCircle === true) {
							objectSizeX = selectedObject.radius;
							objectSizeY = selectedObject.radius;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isText === true) {
							objectSizeX = selectedObject.getWidth();
							objectSizeY = selectedObject.getHeight();
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						break;

				}
			}
			
		});

		function drawScaleOverlay() {
			//using separate canvas for this
			
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
			
			//draw overlay
			
			var POINT_OFFSET = 10;
			
			if (selectedObject.stroke === true) {
				POINT_OFFSET += selectedObject.strokeSize/2;
			}
			
			squareSize = 7;
			
			
			overlayCtx.save();
			
			var selectedDims = {x: selectedObject.x, y: selectedObject.y, rotation: selectedObject.rotation};
			var parentDims = selectedObject.addParentProperties();
			
			selectedDims.x += parentDims.x;
			selectedDims.y += parentDims.y;
			selectedDims.rotation += parentDims.rotation;
			
			if (selectedObject.isRectangle === true || selectedObject.isImage === true) {
				selectedDims.width = selectedObject.width;
				selectedDims.height = selectedObject.height;
			}
			if (selectedObject.isCircle === true) {
				selectedDims.x -= selectedObject.radius;
				selectedDims.y -= selectedObject.radius;
				selectedDims.width = selectedObject.radius * 2;
				selectedDims.height = selectedObject.radius * 2;
			}
			if (selectedObject.isText === true) {
				selectedDims.width = selectedObject.getWidth();
				selectedDims.height = selectedObject.getHeight();
			}
			
			overlayCtx.translate(selectedDims.x + selectedDims.width/2,
				selectedDims.y + selectedDims.height/2);
			
			overlayCtx.rotate(selectedDims.rotation);
			
			var dims = {};
			
			dims.left = -selectedDims.width/2 - POINT_OFFSET;
			dims.right = selectedDims.width/2 + POINT_OFFSET;
			dims.top = -selectedDims.height/2 - POINT_OFFSET;
			dims.bottom = selectedDims.height/2 + POINT_OFFSET;
			
			points = {};
			//put these into points because then can be used later
			points.topLeft = {x: dims.left, y: dims.top};
			points.topCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.top};
			points.topRight = {x: dims.right, y: dims.top};
			points.centreRight = {x: dims.right, y: (dims.top-dims.bottom)/2 - dims.top};
			points.bottomRight = {x: dims.right, y: dims.bottom};
			points.bottomCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.bottom};
			points.bottomLeft = {x: dims.left, y: dims.bottom};
			points.centreLeft = {x: dims.left, y: (dims.top-dims.bottom)/2 - dims.top};

			
			overlayCtx.beginPath();
			
			for (var i in points) {
				
				overlayCtx.rect(points[i].x - squareSize/2, points[i].y - squareSize/2,
					squareSize, squareSize);
					
			}
			
			overlayCtx.moveTo(points.topLeft.x, points.topLeft.y);
			for (var i in points) {
				overlayCtx.lineTo(points[i].x, points[i].y);
			}
			
			
			
			overlayCtx.restore();
			
			overlayCtx.closePath();
			overlayCtx.stroke();
			
			//useful later
			pointsObject = {x: selectedDims.x, y: selectedDims.y, 
				width: selectedDims.width, height: selectedDims.height, rotation: selectedDims.rotation};
		}
		
		overlayCanvas.addEventListener('mousemove', function(e) {
			//again use offsetX and offsetY
			if (menusDisabled === false) {
				//remove selections so dragging isn't messed up
				if (window.getSelection) {
					window.getSelection().removeAllRanges();
				} else if (document.selection) {
					document.selection.empty();
				}
				
				var coordText = document.getElementById('coords');
				coordText.innerHTML = "(x: " + e.offsetX + ", y: " + e.offsetY + ")";
				
				var dimX;
				var dimY;
				
				if (selectedObject.isRectangle === true || selectedObject.isImage === true) {
					dimX = "width";
					dimY = "height";
				}
				if (selectedObject.isCircle === true) {
					dimX = "radius";
					dimY = "radius";
				}
				if (selectedObject.isText === true) {
					dimX = "fontSize";
					dimY = "fontSize";
				}
				
				switch(objectDragged) {
					case "object":
						selectedObject.x += e.movementX;
						selectedObject.y += e.movementY;
						
						drawScene();
						drawProperties();
						break;
						
					case "topLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						drawScene();
						drawProperties();
						break;
						
					case "topCentre":
						var diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "topRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						var diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "centreLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						drawScene();
						drawProperties();
						
						break;
						
					case "bottomLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						
						drawScene();
						drawProperties();
						break;
						
					case "bottomCentre":
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						drawScene();
						drawProperties();
						break;
						
					case "bottomRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						drawScene();
						drawProperties();
						break;
					
					case "centreRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						drawScene();
						drawProperties();	
						break;
						
					case "":
						var result = mouseOnOverlay(e.offsetX, e.offsetY);
						switch(result) {
							case "topLeft":
								overlayCanvas.style.cursor = "nw-resize";
								break;
							case "centreLeft":
								overlayCanvas.style.cursor = "w-resize";
								break;
							case "bottomLeft":
								overlayCanvas.style.cursor = "sw-resize";
								break;
							case "bottomCentre":
								overlayCanvas.style.cursor = "s-resize";
								break;
							case "bottomRight":
								overlayCanvas.style.cursor = "se-resize";
								break;
							case "centreRight":
								overlayCanvas.style.cursor = "e-resize";
								break;
							case "topRight":
								overlayCanvas.style.cursor = "ne-resize";
								break;
							case "topCentre":
								overlayCanvas.style.cursor = "n-resize";
								break;
							case true:
									//support for chrome
									overlayCanvas.style.cursor = "-webkit-grab";
									//overlayCanvas.style.cursor = "move";
								break;
							case false:
								overlayCanvas.style.cursor = "auto";
								break;
						}
						break;
				}
			}
		});
		
		function mouseOnOverlay(mouseX, mouseY) {
			
			var newX = mouseX - (pointsObject.x + pointsObject.width/2);
			var newY = mouseY - (pointsObject.y + pointsObject.height/2);
			
			var newMouseX = newX * Math.cos(-pointsObject.rotation) - newY * Math.sin(-pointsObject.rotation);
			var newMouseY = newX * Math.sin(-pointsObject.rotation) + newY * Math.cos(-pointsObject.rotation);
			
			mouseX = newMouseX + pointsObject.x + pointsObject.width/2;
			mouseY = newMouseY + pointsObject.y + pointsObject.height/2;
			
			//checks if on a point
			for (var i in points) {
				var newPointX = points[i].x// * Math.cos(pointsObject.rotation) - points[i].y;
				var newPointY = points[i].y// * Math.sin(pointsObject.rotation) + points[i].x;
				
				if (mouseX >= newPointX + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
					mouseX <= newPointX + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
					mouseY >= newPointY + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
					mouseY <= newPointY + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
						return i;
				}
			}
			//checks if in rectangle
			if (mouseX >= points.centreLeft.x + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
				mouseX <= points.centreRight.x + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
				mouseY >= points.topCentre.y + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
				mouseY <= points.bottomCentre.y + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
					return true;
			}
			return false;
		}
		
		/*
		** EXPORTING/
		** IMPORTING
		*/
		
		function produceDocument() {
			var exportDoc;
			var j;
			
			exportDoc = "\<!DOCTYPE html\>\n";
			exportDoc += "\<html\>\n";
			exportDoc += "\<body\>\n";
			exportDoc += "\<script src='mylibrary.js'\>" + "\</script\>\n";
			exportDoc += "\<script\>\n";
			
			for (var i=0;i<globalVariables.length;i++) {
				exportDoc += "var " + globalVariables[i][0];
				if (globalVariables[i][1] !== undefined && globalVariables[i][1] !== null) {
					exportDoc += " = " + globalVariables[i][1] + ";\n";
				} else {
					exportDoc += ";\n";
				}
			}
			
			exportDoc += "MYLIB.createCanvas()\n";
			
			for (var i=0;i<scenes.length;i++) {
				j=0;
				addText(scenes[i]);
			}
			
			exportDoc += "\</script\>\n";
			exportDoc += "\</body\>\n";
			exportDoc += "\</html\>\n";
			
			function addText(object) {
				j++;
				var name = object.constructor.name + i + j;
				exportDoc += "var " + name + 
					" = new MYLIB." + object.constructor.name + "();\n";
				
				//make sure only set necessary things
				var base = new object.constructor();
				for (var k in object) {
					if (base[k] !== object[k]) {
						if (k === "children") {
							for (var l=0;l<object.children.length;l++) {
								var tempName = addText(object.children[l]);
								exportDoc += name + ".add(" + tempName + ");\n";
							}
						} else if (k === "scripts") {
							for (var m=0;m<object.scripts.length;m++) {
								exportDoc += name + ".addScript(`" + object.scripts[m].code + "`, \"" + object.scripts[m].name + "\");\n";
							}
						} else if (k !== "parent") {
							if (typeof object[k] === "string") {
								exportDoc += object.constructor.name + i + j + "." + k + " = \"" + object[k] + "\";\n";
							} else {
								exportDoc += object.constructor.name + i + j + "." + k + " = " + object[k] + ";\n";
							}
						}
					}
				}
				return name;
			}
			return exportDoc;
		}
		
		function exportFile() {
			var content = produceDocument();
			var fileName = "test.html";
			
			//download(fileName, content);
			var element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
			element.setAttribute('download', fileName);
		
			element.style.display = 'none';
			document.body.appendChild(element);
		
			element.click();
		
			document.body.removeChild(element);
		}
		
		function readDocument(readDoc) {
			//validateDocument();
			//if (confirm("Your stuff will be overwritten")) {
				console.log(readDoc);
				var newlineregex = RegExp("\n|;", "g");
				var newlines = [];
				var match;
				
				while (match = newlineregex.exec(readDoc)) {
					newlines.push(match.index);
				
				}
				for (var i=0;i<newlines.length;i++) {
					if (i===0) {
						var tempString = readDoc.substring(0, newlines[0]);
					} else {
						var tempString = readDoc.substring(newlines[i-1], newlines[i]);
					}
					
				}
				
			//}
		}
		
		function validateDocument(readDoc) {
			//:/
		}
		
		function importFile() {
			var importfile = document.getElementById('importButton');
			
			var filereader = new FileReader();
			filereader.readAsText(importfile.files[0]);
			filereader.onload = function() {
				readDocument(filereader.result);
			};
		}
		
		/*
			Functions that change the layout of the page
		*/
		function showScene() {
			document.getElementById('sceneOverview').style.display = "block";
			document.getElementById('projectOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "none";
		}
		
		function showProject() {
			document.getElementById('projectOverview').style.display = "block";
			document.getElementById('sceneOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "none";
		}
		
		function showVariables() {
			document.getElementById('projectOverview').style.display = "none";
			document.getElementById('sceneOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "block";
		}
		
		function detachTextEditor() {
			var myStyleSheet;
			var screenWidth = screen.width, screenHeight = screen.height;
			newWindow = window.open("", "textEditWindow", "width=" + screenWidth + ", height=" + screenHeight + ", location=no, left=0");
			newWindow.document.body.append(textArea);
			newWindow.window.addEventListener('unload', function() {
				console.log("Put text area back");
			});
			newWindow.document.title = "Text Editor";
			
			window.onunload = function() {
				newWindow.close();
			};
			
			myStyleSheet = document.createElement('style');
			myStyleSheet.appendChild(document.createTextNode(""));
			myStyleSheet.type = "text/css"
			myStyleSheet.innerHTML = (`textarea { display: block; width: 100%; height: 100%;
			box-sizing: border-box; resize: none;} body { margin: 0; border: 0;}`);
			
			newWindow.document.head.appendChild(myStyleSheet);
		}
		
		function increaseFontSize() {
			changeFontSize(1);
		}
		
		function decreaseFontSize() {
			changeFontSize(-1);
		}
		
		function changeFontSize(amount) {
			var fontSize = parseFloat(window.getComputedStyle(textArea).getPropertyValue('font-size'));
			textArea.style.fontSize = fontSize + amount + 'px';
		}
		
		function play() {
			if (menusDisabled === false) {
				MYLIB.setCanvas(displayCanvas);
				overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				MYLIB.clear();
				
				for (var i=0;i<globalVariables.length;i++) {
					window[globalVariables[i][0]] = globalVariables[i][1];
				}
				
				MYLIB.run(scene.clone());
				running = true;
				disableMenus();
			}
			if (paused === true) {
				MYLIB.run(scene.clone());
				running = true;
				paused = false;
			}
		}
		
		function pause() {
			MYLIB.pause();
			paused = true;
			running = false;
		}
		
		function stop() {
			MYLIB.stop();
			MYLIB.setCanvas(canvas);
			paused = false;
			running = false;
			drawScene();
			enableMenus();
		}
		
		function updateCode() {
			//change number for index of script
			var value = document.getElementById("scriptSelect").value;
			selectedObject.updateScript(value, textArea.value);
		}
		
		function createScript() {
			textArea.value = "";//default script
			selectedObject.addScript(textArea.value);
			addScriptOption(selectedObject.scripts[selectedObject.scripts.length - 1]);
			textArea.readOnly = false;
		}
		
		function addScriptOption(script) {
			var temp = document.createElement("OPTION");
			temp.value = script.index;
			temp.innerHTML = script.name;
			document.getElementById("scriptSelect").appendChild(temp);
		}
		
		function scriptChange() {
			var value = document.getElementById("scriptSelect").value;
			if (selectedObject.scripts[value] !== undefined) {
				textArea.value = selectedObject.scripts[value].code;
				textArea.readOnly = false;
			} else {
				textArea.value = "This object has no scripts";
				textArea.readOnly = true;
			}
		}
		
		function disableMenus() {
			menusDisabled = true;
			
			var properties = document.getElementsByClassName("properties");
			for (var i=0;i<properties.length;i++) {
				properties[i].readOnly = true;
				properties[i].disabled = true;
			}
			
			var sceneChildren = document.getElementsByClassName("sceneChild");
			for (var i=0;i<sceneChildren.length;i++) {
				sceneChildren[i].draggable = false;
			}
			
			textArea.readOnly = true;
			textArea.disabled = true;
			
		}
		
		function enableMenus() {
			menusDisabled = false;
			
			var properties = document.getElementsByClassName("properties");
			for (var i=0;i<properties.length;i++) {
				properties[i].readOnly = false;
				properties[i].disabled = false;
			}
			
			var sceneChildren = document.getElementsByClassName("sceneChild");
			for (var i=0;i<sceneChildren.length;i++) {
				sceneChildren[i].draggable = true;
			}
			
			textArea.readOnly = false;
			textArea.disabled = false;
		}
		
	</script>
	
</body>
</html>