<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div id="header">
		<div id="properties">
			<div id="propertiesTitle"></div>
		</div><!--Using a comment to remove whitespace
		--><div id="overview">
			<div id="sceneOverview">
				<div id="currentScene">
				
				</div>
				
				<div id="allScenes">
				
				</div>
			</div>
			<div id="projectOverview">
				Project Overview
			</div>
			<div id="buttons">
				<button id="sceneButton" onclick="showScene()">Scene Overview</button>
				
				<button id="projectButton" onclick="showProject()">Project Overview</button>
			</div>
		</div>
	</div>
	<div id="main">
		<div id="viewport">
			<canvas id="canvas"></canvas>
			<div id="toolbar">
				<span id="toolbarLeftButtons">
					<button id="addButton">Add</button>
					
				</span>
				
				<span id="toolbarCentreButtons">
					<button onclick="play()" id="play">Play</button>
					
					<button id="pause">Pause</button>
					
					<button id="stop">Stop</button>
				</span>
				
				<span id="toolbarRightButtons">
				
				</span>
			</div>
		</div><!--Using a comment to remove whitespace
		--><div id="textEditor">
			<textarea spellcheck="false" oninput="updateCode()" id="textArea">function start() {

}

function update() {
	this.x += 1;
}</textarea>
			<div id="textToolbar">
				<button onclick="detachTextEditor()" id="detachButton">Detach</button>
				<button onclick="increaseFontSize()" id="increaseSizeButton">+</button>
				<button onclick="decreaseFontSize()" id="decreaseSizeButton">-</button>
			</div>
		</div>
	</div>
	
	<script src="mylibrary.js"></script>
	<script>
		
		//set up canvas
		var canvas = document.getElementById('canvas');
		canvas.width = parseFloat(window.getComputedStyle(canvas).getPropertyValue('width'));
		canvas.height = parseFloat(window.getComputedStyle(canvas).getPropertyValue('height'));
		
		var textArea = document.getElementById('textArea');
		
		MYLIB.setCanvas(canvas);
		
		MYLIB.runSpontaneously = false;
		
		var scene = new MYLIB.Scene();
		scene.addScript(`function update() {
							MYLIB.clear();
							this.draw();
						 }
		`, 'default');//default code to be run in the scene
		
		
		
		var circ = new MYLIB.Circle(350, 100, 60);
		scene.add(circ);
		
		var rect2 = new MYLIB.Rectangle(50, 100, 100, 50);
		
		rect2.name = "fireRect";
		rect2.fill = true;
		rect2.fillColour = "red";
		
		var rect = new MYLIB.Rectangle(30, 30, 100, 50);
		scene.add(rect);
		rect.addScript(textArea.value);
		var selectedObject = rect;
		
		rect.add(rect2);
		
		var rect3 = new MYLIB.Rectangle(10, 10, 50, 20);
		rect3.name = "testRecto";
		rect2.add(rect3);
		
		var activeScene = scene;
		
		drawScene();
		
		//DEFINING PROPERTIES FOR EACH OBJECT
		
		var properties = document.getElementById('properties');
		
		function drawProperties() {
			
			updatePropertiesName();
						
			//remove all current stuff in properties
			
			var currProperties = document.getElementsByClassName("propertyColumn");
			var propLength = currProperties.length;
			for (var i=0;i<propLength;i++) {
				properties.removeChild(currProperties[0]);
			}
			
			//decide how many columns to have based on the selected object
			
			var numOfColumns = 3;
			
			//column 1 is x, y, size, rotation stuff
			
			//column 2 is fill/stroke and visiblity colour stuff
			
			//column 3 is name and /misc
			
			//[name of property, size]
			
			//later make this an object system with a name of property, size of box,
			//type of property, max length of box, etc.
			var Columns = [[["x", 1, "number"], ["y", 1, "number"], ["width", 1, "number"], 
				["height", 1, "number"], ["radius", 1, "number"], ["rotation", 1, "number"]],
				[["fill", 3, "boolean"], ["fillColour", 4, "colour"], ["stroke", 3, "boolean"], 
				["strokeColour", 3, "colour"], ["strokeSize", 1, "number"]], [["visible", 3, "boolean"], 
				["opacity", 2, "number"], ["name", 10, "text"]]];
			
			//"name", "visible", "fill", "fillColour", "stroke", "strokeColour",
			
			for (var j=0;j<numOfColumns;j++) {
				var column = document.createElement("DIV");
				column.className = "propertyColumn";
				column.style.width = 100 / numOfColumns + "%";
				
				for (var i=0;i<Columns[j].length;i++) {
					if (selectedObject[Columns[j][i][0]] !== undefined) {
						//work out what input is necessary
						
						let myinput = document.createElement("INPUT");
						myinput.type = 'text';
						
						myinput.className = "properties";
						
						myinput.property = Columns[j][i][0];
						myinput.propertyType = Columns[j][i][2];
						
						myinput.setAttribute("value", selectedObject[Columns[j][i][0]]);
						
						myinput.style.textAlign = "center";
						myinput.setAttribute("size", Columns[j][i][1]);
						
						//can't use innerHTML directly on properties because it overwrites event listeners
						let text = document.createElement("SPAN");
						text.innerHTML += "<br>" + Columns[j][i][0] + ": ";
						column.appendChild(text);
						
						column.appendChild(myinput);
						myinput.addEventListener('input', updateProperties);
						//myinput.value = selectedObject[Column1[i]];
						
						
					}
				}
				properties.appendChild(column);
			}
			
			/*for (var i in selectedObject) {
				for (var j=0;j<RectangleProperties.length;j++) {
					if (RectangleProperties[j] === i) {
						properties.innerHTML += "<br>" + i + ": " + selectedObject[i] + "";	
					}
				}
			}
			
			if (selectedObject["x"] !== undefined) {
				properties.innerHTML += "<br>x: " + selectedObject["x"] + "";	
			}*/
			
		}
		drawProperties();
		
		function updatePropertiesName() {
			document.getElementById("propertiesTitle").innerHTML = "Properties for " + selectedObject.name;
		}
		
		function updateProperties(e) {
			switch(e.srcElement.propertyType) {
			
				case "number":
					if (!isNaN(e.srcElement.value) && e.srcElement.value !== "") {
						selectedObject[e.srcElement.property] = parseFloat(e.srcElement.value);
						drawScene();
					}
					break;
					
				case "boolean":
					if (e.srcElement.value === "true" || e.srcElement.value === "false") {
						//parse as boolean
						selectedObject[e.srcElement.property] = (e.srcElement.value == "true");
						drawScene();
					}
					break;
				
				case "colour":
					selectedObject[e.srcElement.property] = e.srcElement.value;
					drawScene();
					break;
				
				case "text":
					selectedObject[e.srcElement.property] = e.srcElement.value;
					drawScene();
					if (e.srcElement.property === "name") {
						document.getElementById("propertiesTitle").innerHTML = "Properties for " + selectedObject.name;
						drawSceneOverview();
					}
					break;
					
				default:
					console.log("property type wrong?", e.srcElement.propertyType);
				
			}
		}
		
		//END OF PROPERTIES
		
		var beingDragged;
		
		function drawSceneOverview() {
			var sceneOverview = document.getElementById("sceneOverview");
			//do current scene first
			var currScene = document.getElementById("currentScene");
			
			var changedScene = false;
			
			//clear sceneoverview first
			while (currScene.children.length>0) {
				currScene.removeChild(currScene.children[0]);
			}
			
			currScene.addEventListener("dragover", function(e) {
				e.preventDefault();
			});
				
			currScene.addEventListener("drop", function(e) {
				e.preventDefault();
				if (changedScene === false) {
					beingDragged.parentElement.removeChild(beingDragged);
							
					currScene.appendChild(beingDragged);
					
					activeScene.add(beingDragged.object);
					
					//beingDragged.insertAdjacentHTML("beforebegin", "&emsp;");
					beingDragged.style.marginLeft = "0px"
					drawScene();
				}
			});
			
			for (var i=0;i<activeScene.children.length;i++) {
				addElement(activeScene.children[i]);
				function addElement(object) {
				
					let DOMElement = document.createElement("SPAN");
					
					DOMElement.innerHTML = object.name + "<br>";
					
					DOMElement.className = "sceneChild";
					DOMElement.object = object;
					
					DOMElement.draggable = true;
					
					DOMElement.addEventListener("dragstart", function(e) {
						beingDragged = e.target;
						e.target.style.border = "solid 1px black";
						//console.log(e.target.innerHTML);
						changedScene = false;
					});
					
					DOMElement.addEventListener("dragover", function(e) {
						e.preventDefault();
					});
					
					DOMElement.addEventListener("dragend", function(e) {
						DOMElement.style.border = "initial";
						//console.log(DOMElement.className);
					});
					
					DOMElement.addEventListener("drop", function(e) {
						e.preventDefault();
						changedScene = true;
						//prevent childing self and to child
						if (beingDragged !== e.target && !isRelated(beingDragged, e.target)) {
							//e.target.add(beingDragged);//fix this
							beingDragged.parentElement.removeChild(beingDragged);
							
							e.target.appendChild(beingDragged);
							
							e.target.object.add(beingDragged.object);
							
							//beingDragged.insertAdjacentHTML("beforebegin", "&emsp;");
							beingDragged.style.marginLeft = "26px"
							drawScene();
						}
					});
					
					addChildren(DOMElement);
					
					if (object.parent.constructor.name === "Scene") {
						currScene.appendChild(DOMElement);
					} else {
						return DOMElement;
					}
					
					function addChildren(element) {
						for (var i=0;i<element.object.children.length;i++) {
							var ele = addElement(element.object.children[i]);
							if (ele !== undefined) {
								ele.style.marginLeft = "26px";
								element.appendChild(ele);
							}
						}
					}
				}
			}
		}
		drawSceneOverview();
		
		function isRelated(element, element2) {
			for (var i=0;i<element.children.length;i++) {
				if (element2 === element.children[i]) {
					return true;
				}
			}
			for (var i=0;i<element2.children.length;i++) {
				if (element === element2.children[i]) {
					return true;
				}
			}
			return false;
		}
		
		function drawScene() {
			MYLIB.clear();
			activeScene.draw();
		}

		textArea.addEventListener('keydown', function(e) {
			if (e.key === "Tab") {
				e.preventDefault();
				var caretStart = textArea.selectionStart;
				var caretEnd = textArea.selectionEnd;
				textArea.value = textArea.value.substring(0, caretStart) + "    " + textArea.value.substring(caretEnd);
				textArea.selectionEnd = textArea.selectionStart = caretStart + 4;
			}
		});
		
	
		/*
			Functions that change the layout of the page
		*/
		function showScene() {
			document.getElementById('sceneOverview').style.display = "block";
			document.getElementById('projectOverview').style.display = "none";
		}
		
		function showProject() {
			document.getElementById('projectOverview').style.display = "block";
			document.getElementById('sceneOverview').style.display = "none";
		}
		
		function detachTextEditor() {
			var myStyleSheet;
			var screenWidth = screen.width, screenHeight = screen.height;
			newWindow = window.open("", "textEditWindow", "width=" + screenWidth + ", height=" + screenHeight + ", location=no, left=0");
			newWindow.document.body.append(textArea);
			newWindow.window.addEventListener('unload', function() {
				console.log("Put text area back");
			});
			newWindow.document.title = "Text Editor";
			
			window.onunload = function() {
				newWindow.close();
			};
			
			myStyleSheet = document.createElement('style');
			myStyleSheet.appendChild(document.createTextNode(""));
			myStyleSheet.type = "text/css"
			myStyleSheet.innerHTML = (`textarea { display: block; width: 100%; height: 100%;
			box-sizing: border-box; resize: none;} body { margin: 0; border: 0;}`);
			
			newWindow.document.head.appendChild(myStyleSheet);
		}
		
		function increaseFontSize() {
			changeFontSize(1);
		}
		
		function decreaseFontSize() {
			changeFontSize(-1);
		}
		
		function changeFontSize(amount) {
			var fontSize = parseFloat(window.getComputedStyle(textArea).getPropertyValue('font-size'));
			textArea.style.fontSize = fontSize + amount + 'px';
		}
		
		function play() {
			MYLIB.run(scene);
		}
		
		function updateCode() {
			console.log(textArea.value);
			selectedObject.updateScript(0, textArea.value);
		}
		
		
	</script>
	
</body>
</html>