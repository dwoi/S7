<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div id="header">
		<div id="properties">
			<div id="propertiesTitle"></div>
		</div><!--Using a comment to remove whitespace
		--><div id="overview">
			<div id="sceneOverview">
				<div id="currentScene">
				
				</div>
				
				<div id="allScenes">
				
				</div>
			</div>
			<div id="projectOverview">
				Project Overview
			</div>
			<div id="buttons">
				<button id="sceneButton" onclick="showScene()">Scene Overview</button>
				
				<button id="projectButton" onclick="showProject()">Project Overview</button>
			</div>
		</div>
	</div>
	<div id="main">
		<div id="viewport">
			<canvas id="overlayCanvas"></canvas>
			<canvas id="canvas"></canvas>
			<div id="toolbar">
				<span id="toolbarLeftButtons">
					<button id="addButton">Add</button>
					<div id="dropdownAddButtons">
						<button class="addObjectButton" id="addRect" onclick="addObject('Rectangle')">Add Rectangle</button>
						<button class="addObjectButton" id="addCircle" onclick="addObject('Circle')">Add Circle</button>
					</div>
				</span>
				
				<span id="toolbarCentreButtons">
					<button onclick="play()" id="play">Play</button>
					
					<button onclick="pause()" id="pause">Pause</button>
					
					<button onclick="stop()" id="stop">Stop</button>
				</span>
				
				<span id="coords">
					text
				</span>
				
				<!--<span id="toolbarRightButtons">
					
				</span>-->
			</div>
		</div><!--Using a comment to remove whitespace
		--><div id="textEditor">
			<textarea spellcheck="false" oninput="updateCode()" id="textArea"></textarea>
			<div id="textToolbar">
				<button onclick="detachTextEditor()" class="textButtons" id="detachButton">Detach</button>
				<button onclick="increaseFontSize()" class="textButtons" id="increaseSizeButton">Size +</button>
				<button onclick="decreaseFontSize()" class="textButtons" id="decreaseSizeButton">Size -</button>
				<select onchange="scriptChange()" id="scriptSelect"></select>
				<button onclick="createScript()" class="textButtons" id="addScriptButton">New script</button>
			</div>
		</div>
	</div>
	
	<script src="mylibrary.js"></script>
	<script>
	
		"use script";
		
		//set up canvas
		var canvas = document.getElementById('canvas');
		canvas.width = parseFloat(window.getComputedStyle(canvas).getPropertyValue('width'));
		canvas.height = parseFloat(window.getComputedStyle(canvas).getPropertyValue('height'));
		
		var overlayCanvas = document.getElementById("overlayCanvas");
		var overlayCtx = overlayCanvas.getContext('2d');
		
		overlayCanvas.style.width = canvas.width;
		overlayCanvas.style.height = canvas.height;
		
		overlayCanvas.width = canvas.width;
		overlayCanvas.height = canvas.height;

		var textArea = document.getElementById('textArea');
		textArea.value = `function start() {\n    \n}\n\nfunction update() {\n    this.x += 1;\n}`;
		
		var points = {};
		var squareSize;
		var pointsObject;
		
		var objectDragged;
		
		var changedScene;
		
		var objectPosX;
		var objectPosY;
		
		var objectSizeX;
		var objectSizeY;
		
		var mouseDown = false;
		
		var running = false;
		var paused = false;
		
		//Command Pattern system
		
		class History {
			constructor() {
				this.undos = [];
				this.history = [];
			}
			
			undo() {
				if (this.history.length>0) {
					this.history[this.history.length-1].undo();
					this.undos.push(this.history.pop());
				}
			}
			
			redo() {
				if (this.undos.length>0) {
					this.undos[this.undos.length-1].run();
					this.history.push(this.undos.pop());
				}
			}
			
			run(command) {
				command.run();
				this.history.push(command);
				this.redos = [];
			}
			
			add(command) {
				this.history.push(command);
				this.redos = [];
			}
		}
		
		class ChangePositionCommand {
			constructor(object, origPosX, origPosY, newPosX, newPosY) {
				this.object = object;
				this.origPosX = origPosX;
				this.origPosY = origPosY;
				this.newPosX = newPosX;
				this.newPosY = newPosY;
			}
			
			undo() {
				console.log(this.object);
				this.object.x = this.origPosX;
				this.object.y = this.origPosY;
				drawScene();
				drawProperties();
			}
			
			run() {
				this.object.x = this.newPosX;
				this.object.y = this.newPosY;
				drawScene();
				drawProperties();
			}
		}
		
		class ChangePropertyCommand {
			constructor(object, property, origProp, newProp) {
				this.object = object;
				this.property = property;
				this.origProp = origProp;
				this.newProp = newProp;
			}
			
			undo() {
				console.log(this);
				this.object[this.property] = this.origProp;
				drawScene();
				//drawProperties();
			}
			
			run() {
				this.object[this.property] = this.newProp;
				drawScene();
				//drawProperties();
			}
		}
		
		class ChangeHierachyCommand {
			constructor(object, oldParent, newParent, element, oldParentEle, newParentEle) {
				this.object = object;
				this.oldParent = oldParent;
				this.newParent = newParent;
				this.element = element;
				this.oldParentEle = oldParentEle;
				this.newParentEle = newParentEle;
			}
			
			run() {
				this.newParent.add(this.object);
				this.newParentEle.appendChild(this.element);
				if (this.newParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
			
			undo() {
				this.oldParent.add(this.object);
				this.oldParentEle.appendChild(this.element);
				if (this.oldParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
		}
		
		class ChangeSizeCommand {
			constructor(object, oldWidth, oldHeight, newWidth, newHeight, oldX, oldY, newX, newY) {
				this.object = object;
				console.log(object);
				if (object.isRectangle === true) {
					this.propertyX = "width";
					this.propertyY = "height";
				}
				if (object.isCircle === true) {
					this.propertyX = "radius";
					this.propertyY = "radius";
				}
				this.oldWidth = oldWidth;
				this.newWidth = newWidth;
				this.oldHeight = oldHeight;
				this.newHeight = newHeight;
				this.oldX = oldX;
				this.oldY = oldY;
				this.newX = newX;
				this.newY = newY;
			}
			
			run() {
				this.object[this.propertyX] = this.newWidth;
				this.object[this.propertyY] = this.newHeight;
				this.object.x = this.newX;
				this.object.y = this.newY;
				drawScene();
			}
			
			undo() {
				this.object[this.propertyX] = this.oldWidth;
				this.object[this.propertyY] = this.oldHeight;
				this.object.x = this.oldX;
				this.object.y = this.oldY;
				drawScene();
			}
		}
		
		MYLIB.setCanvas(canvas);
		
		MYLIB.runSpontaneously = false;
		
		var scene = new MYLIB.Scene();
		scene.addScript(`function update() {\n    MYLIB.clear();\n    this.draw();\n}`,
			'default');//default code to be run in the scene
		
		
		
		var circ = new MYLIB.Circle(350, 100, 60);
		scene.add(circ);
		
		var rect2 = new MYLIB.Rectangle(50, 100, 100, 50);
		
		rect2.name = "fireRect";
		rect2.fill = true;
		rect2.fillColour = "#FF0000";
		
		var rect = new MYLIB.Rectangle(30, 300, 100, 50);
		rect.rotation = 1;
		scene.add(rect);
		rect.addScript(textArea.value);	
		addScriptOption(rect.scripts[0]);
		
		rect.addScript(`function start() {\n    this.fill = true;\n    this.fillColour = "green";\n}`);
		addScriptOption(rect.scripts[1]);
		//add that script
		
		var selectedObject = rect;
		
		scene.add(rect2);
		
		var rect3 = new MYLIB.Rectangle(10, 10, 50, 20);
		rect3.name = "testRecto";
		rect2.add(rect3);
		
		var activeScene = scene;
		
		var _history = new History();
		
		drawScene();
		
		//DEFINING PROPERTIES FOR EACH OBJECT
		
		var properties = document.getElementById('properties');
		
		function drawProperties() {
			
			updatePropertiesName();
						
			//remove all current stuff in properties
			
			var currProperties = document.getElementsByClassName("propertyColumn");
			var propLength = currProperties.length;
			for (var i=0;i<propLength;i++) {
				properties.removeChild(currProperties[0]);
			}
			
			//decide how many columns to have based on the selected object
			
			var numOfColumns = 3;
			
			//column 1 is x, y, size, rotation stuff
			
			//column 2 is fill/stroke and visiblity colour stuff
			
			//column 3 is name and /misc
			
			//[name of property, size]
			
			//later make this an object system with a name of property, size of box,
			//type of property, max length of box, etc.
			var Columns = [[["x", 1, "number"], ["y", 1, "number"], ["width", 1, "number"], 
				["height", 1, "number"], ["radius", 1, "number"], ["rotation", 1, "number"]],
				[["fill", 3, "boolean"], ["fillColour", 4, "colour"], ["stroke", 3, "boolean"], 
				["strokeColour", 3, "colour"], ["strokeSize", 1, "number"]], [["visible", 3, "boolean"], 
				["opacity", 2, "number"], ["name", 10, "text"]]];
			
			//"name", "visible", "fill", "fillColour", "stroke", "strokeColour",
			
			for (var j=0;j<numOfColumns;j++) {
				var column = document.createElement("DIV");
				column.className = "propertyColumn";
				column.style.width = 100 / numOfColumns + "%";
				
				for (var i=0;i<Columns[j].length;i++) {
					if (selectedObject[Columns[j][i][0]] !== undefined) {
						//work out what input is necessary
						
						let myinput = document.createElement("INPUT");
						
						
						myinput.className = "properties";
						
						myinput.property = Columns[j][i][0];
						myinput.propertyType = Columns[j][i][2];
						
						if (myinput.propertyType === "number" || myinput.propertyType === "text") {
							myinput.type = 'text';
						
							myinput.setAttribute("value", selectedObject[Columns[j][i][0]]);
							
							myinput.style.textAlign = "center";
							myinput.setAttribute("size", Columns[j][i][1]);
							
							myinput.addEventListener('input', updateProperties);
						}
						
						if (myinput.propertyType === "colour") {
							myinput.type = 'color';
							myinput.setAttribute("value", selectedObject[Columns[j][i][0]]);
							//myinput.setAttribute("value", "#FF0000");
							
							myinput.addEventListener('input', updateProperties);
						}
						
						if (myinput.propertyType === "boolean") {
							myinput.type = 'checkbox';
							
							if (selectedObject[Columns[j][i][0]] === true) {
								myinput.checked = true;
							}
							//myinput.setAttribute("value", selectedObject[Columns[j][i][0]]);
							
							myinput.addEventListener('change', updateProperties);
						}
						
						/*if (myinput.propertyType === "text") {
						
						}*/
						
						//can't use innerHTML directly on properties because it overwrites event listeners
						let text = document.createElement("SPAN");
						text.innerHTML += "<br>" + Columns[j][i][0] + ": ";
						column.appendChild(text);
						
						column.appendChild(myinput);
						
						//myinput.value = selectedObject[Column1[i]];
						
						
					}
				}
				properties.appendChild(column);
			}
			
			/*for (var i in selectedObject) {
				for (var j=0;j<RectangleProperties.length;j++) {
					if (RectangleProperties[j] === i) {
						properties.innerHTML += "<br>" + i + ": " + selectedObject[i] + "";	
					}
				}
			}
			
			if (selectedObject["x"] !== undefined) {
				properties.innerHTML += "<br>x: " + selectedObject["x"] + "";	
			}*/
			
		}
		drawProperties();
		
		function updatePropertiesName() {
			document.getElementById("propertiesTitle").innerHTML = "Properties for " + selectedObject.name;
		}
		
		function updateProperties(e) {
			switch(e.srcElement.propertyType) {
			
				case "number":
					if (!isNaN(e.srcElement.value) && e.srcElement.value !== "") {
						_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property,
							selectedObject[e.srcElement.property], parseFloat(e.srcElement.value)));
						//selectedObject[e.srcElement.property] = parseFloat(e.srcElement.value);
						//drawScene();
					}
					break;
					
				case "boolean":
					
					//parse as boolean
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.checked));
					//selectedObject[e.srcElement.property] = e.srcElement.checked;
					//drawScene();
					break;
				
				case "colour":
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					//drawScene();
					break;
				
				case "text":
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					//drawScene();
					if (e.srcElement.property === "name") {
						updatePropertiesName();
						drawSceneOverview();
					}
					break;
					
				default:
					console.warn("property type wrong?", e.srcElement.propertyType);
				
			}
		}
		
		//END OF PROPERTIES
		
		var elementDragged;
		
		function drawSceneOverview() {
			var sceneOverview = document.getElementById("sceneOverview");
			//do current scene first
			var currScene = document.getElementById("currentScene");
			
			
			
			//clear sceneoverview first
			while (currScene.children.length>0) {
				currScene.removeChild(currScene.children[0]);
			}
			
			currScene.addEventListener("dragover", function(e) {
				e.preventDefault();
			});
				
			currScene.addEventListener("drop", function(e) {
				e.preventDefault();
				
				if (changedScene === false) {
					_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
						activeScene, elementDragged, elementDragged.parentElement, currScene));
					/*elementDragged.parentElement.removeChild(elementDragged);
							
					currScene.appendChild(elementDragged);
					
					activeScene.add(elementDragged.object);
					
					//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
					elementDragged.style.marginLeft = "0px"
					drawScene();*/
				}
			});
			
			for (var i=0;i<activeScene.children.length;i++) {
				addElement(activeScene.children[i]);
				function addElement(object) {
				
					let DOMElement = document.createElement("SPAN");
					
					DOMElement.innerHTML = object.name + "<br>";
					
					DOMElement.className = "sceneChild";
					DOMElement.object = object;
					
					DOMElement.draggable = true;
					
					DOMElement.addEventListener("mouseover", function(e) {
						e.target.style.border = "dashed 1px black";
					});
					
					DOMElement.addEventListener("mouseout", function(e) {
						e.target.style.border = "none";
					});
					
					DOMElement.addEventListener("click", function(e) {
						selectObject(e.target.object);
					});
					
					DOMElement.addEventListener("dragstart", function(e) {
						elementDragged = e.target;
						if (e.target.style.border !== "1px solid black") {
							e.target.style.border = "double 1px black";
						}
						//console.log(e.target.innerHTML);
						changedScene = false;
					});
					
					DOMElement.addEventListener("dragover", function(e) {
						e.preventDefault();
					});
					
					DOMElement.addEventListener("dragend", function(e) {
						DOMElement.style.border = "initial";
						//console.log(DOMElement.className);
					});
					
					DOMElement.addEventListener("drop", function(e) {
						e.preventDefault();
						changedScene = true;
						//prevent childing self and to child
						if (elementDragged !== e.target && !isRelated(elementDragged, e.target)) {
							//e.target.add(elementDragged);//fix this
							_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
								e.target.object, elementDragged, elementDragged.parentElement, e.target));
							/*elementDragged.parentElement.removeChild(elementDragged);
							
							e.target.appendChild(elementDragged);
							
							e.target.object.add(elementDragged.object);
							
							//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
							elementDragged.style.marginLeft = "26px"
							drawScene();*/
						}
					});
					
					addChildren(DOMElement);
					
					if (object.parent.constructor.name === "Scene") {
						currScene.appendChild(DOMElement);
					} else {
						return DOMElement;
					}
					
					function addChildren(element) {
						for (var i=0;i<element.object.children.length;i++) {
							var ele = addElement(element.object.children[i]);
							if (ele !== undefined) {
								ele.style.marginLeft = "26px";
								element.appendChild(ele);
							}
						}
					}
				}
			}
		}
		drawSceneOverview();
		
		//END OF SCENE OVERVIEW
		
		function selectObject(object) {
			selectedObject = object;
			
			drawProperties();
			drawScaleOverlay();
			
			var scriptElement = document.getElementById("scriptSelect");
			scriptElement.value = 0;
			
			//fix script
			while (scriptElement.children.length>0) {
				scriptElement.removeChild(scriptElement.children[0]);
			}
			
			for(var i=0;i<selectedObject.scripts.length;i++) {
				addScriptOption(selectedObject.scripts[i]);
			}
			scriptChange();
		}
		
		function addObject(type) {
			var temp = new MYLIB[type]();
			activeScene.add(temp);
			selectedObject = temp;
			drawSceneOverview();
			drawProperties();
			drawScene();
		}
		
		function isRelated(element, element2) {
			for (var i=0;i<element.children.length;i++) {
				if (element2 === element.children[i]) {
					return true;
				}
			}
			for (var i=0;i<element2.children.length;i++) {
				if (element === element2.children[i]) {
					return true;
				}
			}
			return false;
		}
		
		function drawScene() {
			MYLIB.clear();
			activeScene.draw();
			drawScaleOverlay();
		}

		textArea.addEventListener('keydown', function(e) {
			if (e.key === "Tab") {
				e.preventDefault();
				var caretStart = textArea.selectionStart;
				var caretEnd = textArea.selectionEnd;
				textArea.value = textArea.value.substring(0, caretStart) + "    " + textArea.value.substring(caretEnd);
				textArea.selectionEnd = textArea.selectionStart = caretStart + 4;
			}
		});
		
		document.addEventListener('keydown', function(e) {
			if (e.key === "z" && e.ctrlKey === true) {
				_history.undo();
			}
			if (e.key === "y" && e.ctrlKey === true) {
				_history.redo();
			}
		});
		
		document.addEventListener('mousedown', function(e) {
			mouseDown = true;
		});
		
		document.addEventListener('mouseup', function(e) {
			mouseDown = false;
			if (objectDragged === "object") {
				_history.add(new ChangePositionCommand(selectedObject, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
			}
			if (objectDragged !== true && objectDragged !== false) {
				if (selectedObject.isRectangle === true) {
					console.log(objectSizeX, objectSizeY);
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.width, 
						selectedObject.height, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
					
				}
				if (selectedObject.isCircle === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.radius,
						selectedObject.radius, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
				}
			}
			objectDragged = "";
			if (overlayCanvas.style.cursor === "-webkit-grabbing") {
				overlayCanvas.style.cursor = "-webkit-grab";
			}
		});
		
		document.addEventListener('dragend', function(e) {
			mouseDown = false;
			objectDragged = "";
		});
		
		overlayCanvas.addEventListener('mousedown', function(e) {
			//WORK ROTATION LATER
			if (running === false && paused === false) {
				var result = mouseOnOverlay(e.offsetX, e.offsetY);
				
				switch(result) {
					case true:
						objectDragged = "object";
						overlayCanvas.style.cursor = "-webkit-grabbing";
						break;
						
					case false:
						//using e.offsetX and e.offsetY
						var descendents = activeScene.getAllDescendents();
						var selectedSomething = false;
						for (var i=0;i<descendents.length;i++) {
							var dims = {x: descendents[i].x, y: descendents[i].y};
							var parentDims = descendents[i].addParentProperties();
							
							dims.x += parentDims.x;
							dims.y += parentDims.y;
							
							if (descendents[i].constructor.name === "Rectangle") {
								
								if (e.offsetX >= dims.x && e.offsetY >= dims.y &&
									e.offsetX <= dims.x + descendents[i].width &&
									e.offsetY <= dims.y + descendents[i].height) {
									
									selectObject(descendents[i]);
									objectDragged = "object";
									overlayCanvas.style.cursor = "-webkit-grabbing";
									selectedSomething = true;
									objectPosX = descendents[i].x;
									objectPosY = descendents[i].y;
								}
							}
							if (descendents[i].constructor.name === "Circle") {
								if (Math.hypot(Math.abs(e.offsetX - dims.x), Math.abs(e.offsetY - dims.y)) <= descendents[i].radius) {
									selectObject(descendents[i]);
									objectDragged = "object";
									overlayCanvas.style.cursor = "-webkit-grabbing";
									selectedSomething = true;
									objectPosX = descendents[i].x;
									objectPosY = descendents[i].y;
								}
							}
						}
						if (selectedSomething === false) {
							selectObject(scene);
						}
						break;
						
					default:
						objectDragged = result;
						if (selectedObject.isRectangle === true) {
							objectSizeX = selectedObject.width;
							objectSizeY = selectedObject.height;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isCircle === true) {
							objectSizeX = selectedObject.radius;
							objectSizeY = selectedObject.radius;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						break;

				}
			}
			
		});

		function drawScaleOverlay() {
			//using separate canvas for this
			
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
			
			//draw overlay
			
			var POINT_OFFSET = 10;
			
			if (selectedObject.stroke === true) {
				POINT_OFFSET += selectedObject.strokeSize/2;
			}
			
			squareSize = 7;
			
			
			overlayCtx.save();
			
			var selectedDims = {x: selectedObject.x, y: selectedObject.y, rotation: selectedObject.rotation};
			var parentDims = selectedObject.addParentProperties();
			
			selectedDims.x += parentDims.x;
			selectedDims.y += parentDims.y;
			selectedDims.rotation += parentDims.rotation;
			
			if (selectedObject.constructor.name === "Rectangle") {
				selectedDims.width = selectedObject.width;
				selectedDims.height = selectedObject.height;
			} else if (selectedObject.constructor.name === "Circle") {
				selectedDims.x -= selectedObject.radius;
				selectedDims.y -= selectedObject.radius;
				selectedDims.width = selectedObject.radius * 2;
				selectedDims.height = selectedObject.radius * 2;
			}
			
			overlayCtx.translate(selectedDims.x + selectedDims.width/2,
				selectedDims.y + selectedDims.height/2);
			
			overlayCtx.rotate(selectedDims.rotation);
			
			var dims = {};
			
			dims.left = -selectedDims.width/2 -POINT_OFFSET;
			dims.right = selectedDims.width/2 + POINT_OFFSET;
			dims.top = -selectedDims.height/2 - POINT_OFFSET;
			dims.bottom = selectedDims.height/2 + POINT_OFFSET;
			
			points = {};
			//put these into points because then can be used later
			points.topLeft = {x: dims.left, y: dims.top};
			points.topCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.top};
			points.topRight = {x: dims.right, y: dims.top};
			points.centreRight = {x: dims.right, y: (dims.top-dims.bottom)/2 - dims.top};
			points.bottomRight = {x: dims.right, y: dims.bottom};
			points.bottomCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.bottom};
			points.bottomLeft = {x: dims.left, y: dims.bottom};
			points.centreLeft = {x: dims.left, y: (dims.top-dims.bottom)/2 - dims.top};

			
			overlayCtx.beginPath();
			
			for (var i in points) {
				
				overlayCtx.rect(points[i].x - squareSize/2, points[i].y - squareSize/2,
					squareSize, squareSize);
					
			}
			
			overlayCtx.moveTo(points.topLeft.x, points.topLeft.y);
			for (var i in points) {
				overlayCtx.lineTo(points[i].x, points[i].y);
			}
			
			
			
			overlayCtx.restore();
			
			overlayCtx.closePath();
			overlayCtx.stroke();
			
			//useful later
			pointsObject = {x: selectedDims.x, y: selectedDims.y, 
				width: selectedDims.width, height: selectedDims.height, rotation: selectedDims.rotation};
		}
		
		//doesn't work for rotation yet
		overlayCanvas.addEventListener('mousemove', function(e) {
			//again use offsetX and offsetY
			
			if (window.getSelection) {
				window.getSelection().removeAllRanges();
			} else if (document.selection) {
				document.selection.empty();
			}
			
			var coordText = document.getElementById('coords');
			coordText.innerHTML = "(x: " + e.offsetX + ", y: " + e.offsetY + ")";
			//console.log(e.movementX, e.movementY);
			if (running === false && paused === false) {
				var dimX;
				var dimY;
				
				if (selectedObject.constructor.name === "Rectangle") {
					dimX = "width";
					dimY = "height";
				}
				if (selectedObject.constructor.name === "Circle") {
					dimX = "radius";
					dimY = "radius";
				}
				
				switch(objectDragged) {
					case "object":
						selectedObject.x += e.movementX;
						selectedObject.y += e.movementY;
						
						drawScene();
						drawProperties();
						break;
						
					case "topLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						drawScene();
						drawProperties();
						break;
						
					case "topCentre":
						var diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "topRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						var diff = Math.max(0, selectedObject[dimY] - e.movementY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "centreLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						drawScene();
						drawProperties();
						
						break;
						
					case "bottomLeft":
						var diff = Math.max(0, selectedObject[dimX] - e.movementX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						
						drawScene();
						drawProperties();
						break;
						
					case "bottomCentre":
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						drawScene();
						drawProperties();
						break;
						
					case "bottomRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + e.movementY);
						drawScene();
						drawProperties();
						break;
					
					case "centreRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + e.movementX);
						drawScene();
						drawProperties();	
						break;
						
					case "":
						var result = mouseOnOverlay(e.offsetX, e.offsetY);
						switch(result) {
							case "topLeft":
								overlayCanvas.style.cursor = "nw-resize";
								break;
							case "centreLeft":
								overlayCanvas.style.cursor = "w-resize";
								break;
							case "bottomLeft":
								overlayCanvas.style.cursor = "sw-resize";
								break;
							case "bottomCentre":
								overlayCanvas.style.cursor = "s-resize";
								break;
							case "bottomRight":
								overlayCanvas.style.cursor = "se-resize";
								break;
							case "centreRight":
								overlayCanvas.style.cursor = "e-resize";
								break;
							case "topRight":
								overlayCanvas.style.cursor = "ne-resize";
								break;
							case "topCentre":
								overlayCanvas.style.cursor = "n-resize";
								break;
							case true:
									//support for chrome
									overlayCanvas.style.cursor = "-webkit-grab";
									//overlayCanvas.style.cursor = "move";
								break;
							case false:
								overlayCanvas.style.cursor = "auto";
								break;
						}
						break;
				}
				
			}
		});
		
		function mouseOnOverlay(mouseX, mouseY) {
			//checks if on a point
			for (var i in points) {
				if (mouseX >= points[i].x + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
					mouseX <= points[i].x + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
					mouseY >= points[i].y + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
					mouseY <= points[i].y + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
						return i;
				}
			}
			//checks if in rectangle
			if (mouseX >= points.centreLeft.x + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
				mouseX <= points.centreRight.x + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
				mouseY >= points.topCentre.y + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
				mouseY <= points.bottomCentre.y + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
					return true;
			}
			return false;
		}
		
		
		
		
	
		/*
			Functions that change the layout of the page
		*/
		function showScene() {
			document.getElementById('sceneOverview').style.display = "block";
			document.getElementById('projectOverview').style.display = "none";
		}
		
		function showProject() {
			document.getElementById('projectOverview').style.display = "block";
			document.getElementById('sceneOverview').style.display = "none";
		}
		
		function detachTextEditor() {
			var myStyleSheet;
			var screenWidth = screen.width, screenHeight = screen.height;
			newWindow = window.open("", "textEditWindow", "width=" + screenWidth + ", height=" + screenHeight + ", location=no, left=0");
			newWindow.document.body.append(textArea);
			newWindow.window.addEventListener('unload', function() {
				console.log("Put text area back");
			});
			newWindow.document.title = "Text Editor";
			
			window.onunload = function() {
				newWindow.close();
			};
			
			myStyleSheet = document.createElement('style');
			myStyleSheet.appendChild(document.createTextNode(""));
			myStyleSheet.type = "text/css"
			myStyleSheet.innerHTML = (`textarea { display: block; width: 100%; height: 100%;
			box-sizing: border-box; resize: none;} body { margin: 0; border: 0;}`);
			
			newWindow.document.head.appendChild(myStyleSheet);
		}
		
		function increaseFontSize() {
			changeFontSize(1);
		}
		
		function decreaseFontSize() {
			changeFontSize(-1);
		}
		
		function changeFontSize(amount) {
			var fontSize = parseFloat(window.getComputedStyle(textArea).getPropertyValue('font-size'));
			textArea.style.fontSize = fontSize + amount + 'px';
		}
		
		function play() {
			if (running === false) {
				overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				MYLIB.context.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				MYLIB.run(scene.clone());
				running = true;
			}
		}
		
		function pause() {
			MYLIB.pause();
			paused = true;
			running = false;
		}
		
		function stop() {
			MYLIB.stop();
			paused = false;
			running = false;
			drawScene();
		}
		
		function updateCode() {
			//change number for index of script
			var value = document.getElementById("scriptSelect").value;
			selectedObject.updateScript(value, textArea.value);
		}
		
		function createScript() {
			textArea.value = "";//default script
			selectedObject.addScript(textArea.value);
			addScriptOption(selectedObject.scripts[selectedObject.scripts.length - 1]);
		}
		
		function addScriptOption(script) {
			var temp = document.createElement("OPTION");
			temp.value = script.index;
			temp.innerHTML = script.name;
			document.getElementById("scriptSelect").appendChild(temp);
		}
		
		function scriptChange() {
			var value = document.getElementById("scriptSelect").value;
			if (selectedObject.scripts[value] !== undefined) {
				textArea.value = selectedObject.scripts[value].code;
				textArea.readOnly = false;
			} else {
				textArea.value = "This object has no scripts";
				textArea.readOnly = true;
			}
		}
		
	</script>
	
</body>
</html>