 <!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div id="header">
		<div id="properties">
			<div id="propertiesTitle"></div>
		</div><!--Using a comment to remove whitespace
		--><div id="overview">
			<div id="sceneOverview">
				<div id="currentScene">
				
				</div>
				
				<div id="allScenes">
				
				</div>
			</div>
			<div id="projectOverview">
				<div id="scenesOverview">
				
				</div><!--
				--><div id="sceneButtonContainer">
					<button id="newSceneButton" class="sceneButtons">New Scene</button>
					<button id="deleteSceneButton" class="sceneButtons">Delete Scene</button>
				</div>
			</div>
			<div id="variableOverview">
				<div id="varNameColumn">
					<p class="varHeader">Name</p>
					<div id="varNames"></div>
				</div>
				<div id="varValueColumn">
					<p class="varHeader">Value</p>
					<div id="varValues"></div>
				</div>
				
				<div id="addVariables">
					<button id="addVariableButton">Add Variable</button>
					<textarea placeholder="Variable Name" id="variableName" type="text"></textarea>
				</div>
			</div>
			<div id="buttons">
				<button id="sceneButton">Scene Overview</button>
				
				<button id="projectButton">Project Overview</button>
				
				<button id="variablesButton">Global Variables</button>
			</div>
		</div>
	</div>
	<div id="main">
		<div id="viewport">
			<canvas id="overlayCanvas"></canvas>
			<div id="background">
				<canvas id="canvas"></canvas>
			</div>
			<div id="toolbar">
				<span id="toolbarLeftButtons">
					<button id="addButton">Add</button>
					<div id="dropdownAddButtons">
						<button class="addObjectButton" id="addRect">Add Rectangle</button>
						<button class="addObjectButton" id="addCircle">Add Circle</button>
						<button class="addObjectButton" id="addEllipse">Add Ellipse</button>
						<button class="addObjectButton" id="addText">Add Text</button>
						<button class="addObjectButton" id="addSprite">Add Sprite</button>
						
					</div>
					<button id="exportButton">Export</button>
					<!--<label id="importUI" for="importButton">
						<span id="importText">Import</span>
					</label>-->
					<input type="file" id="importButton">
					<button id="deleteButton">Delete</button>
					<button id="fullScreen">fullscreen</button>
				</span>
				
				<span id="toolbarCentreButtons">
					<button id="play">Play</button>
					
					<button id="pause">Pause</button>
					
					<button id="stop">Stop</button>
				</span>
				
				<span id="coords">
					Co-ords
				</span>
				
				<!--<span id="toolbarRightButtons">
					
				</span>-->
			</div>
		</div><!--Using a comment to remove whitespace
		--><div id="textEditor">
			<textarea spellcheck="false" id="textArea"></textarea>
			<div id="textToolbar">
				<button class="textButtons" id="detachButton">Detach</button>
				<button class="textButtons" id="increaseSizeButton">Size +</button>
				<button class="textButtons" id="decreaseSizeButton">Size -</button>
				<select id="scriptSelect"></select>
				<button class="textButtons" id="addScriptButton">New script</button>
			</div>
		</div>
	</div>
	
	<div id="imageMenu" class="menu">
		<div id="imageBrowser">
			
		</div>
		
		<div id="importArea">
			<label id="imageButton" for="importImageButton">Import Image</label>
			<input type="file" accept="image/*" id="importImageButton">
			
			<figure>
				<img id="imagePreview" src="noimage.png" alt="image preview">
				<figcaption>Image to be inserted</figcaption>
			</figure>
			
			<button id="useImageButton">Use Image</button>
		</div>
	</div>
	
	<div id="confirmationMenu" class="menu">
		
	</div>
	
	<div id="exportMenu" class="menu">
		<div id="exportTitle">
			<img id="exportBackArrow" src="backImg.svg" alt="Go back">
			<h1 id="exportTitleText">Export</h1>
		</div>
		<div id="exportMain">
			<p id="exportText">
				To run the program, you need to have the library in the same folder as the html file
			</p>
			<a href="S7.js" download><button id="exportLibraryButton">Download library</button></a>
			<button id="exportProgramButton">Download program</button>
		</div>
	</div>
	
	<div id="startMenu" class="menu">
		<div id="startUpper">
			<h1 id="welcomeText">Welcome</h1>
		</div>
		<div id="startMain">
			<div id="newArea">
				<button id="newButton">New Project</button>
				
			</div>
			<div id="existingArea">
				
				<div id="existingUpper">
					<h2 id="existingText">Existing Projects:</h2>
				</div>
				
				<div id="existingBrowser">
					
				</div>
				
			</div>
		</div>
	</div>
	
	<div id="newMenu" class="menu">
		<!--menu for creating a new project-->
		<div id="newHeader">
			<img id="backArrow" src="backImg.svg" alt="Go back">
			<h1 id="newText">New Project</h1>
		</div>
		<div id="newSettings"><br>
			<span>Width: </span><input value="500" id="newWidth" type="text"><span>px</span><br><br>
			<span>Height: </span><input value="300" id="newHeight" type="text"><span>px</span><br><br>
			<span title="Always expands to fill maximum area available.">Autosize: </span><input id="newAutoSize" type="checkbox"><br><br>
			<span title="Expands to fill space but keeps ratio of width and height.">Constrain proportions: </span><input id="newConstrain" type="checkbox"><br><br>
			
			<span>Project Name: </span><input value="Untitled Project" id="newProjectName" type="text"><br><br>
			
			<button id="newProjectButton">Create New Project</button>
		</div>
	</div>
	
	<script src="S7.js"></script>
	<script>
		
		(function() {
	
		"use strict";
		
		//set up canvas
		var canvas = document.getElementById("canvas");
		
		var overlayCanvas = document.getElementById("overlayCanvas");
		var overlayCtx = overlayCanvas.getContext('2d');
		
		const SELECTED_BACKGROUND_COLOR = "#3300FF";
		const SELECTED_TEXT_COLOR = "#FFFFFF";
		
		const databaseName = "S7projects";//NOTE CHANGE LATER WHEN PROJECT GETS NAME
		
		var points = {};
		var squareSize;
		var pointsObject;
		
		var objectDragged;
		
		var changedScene;
		
		var objectPosX;
		var objectPosY;
		
		var objectSizeX;
		var objectSizeY;
		
		var sceneOffsetX = 0;
		var sceneOffsetY = 0;
		
		var zoomX = 1;
		var zoomY = 1;
		
		var mousePosX = 0;
		var mousePosY = 0;
		
		var backgroundColour = "#AAAAAA";
		
		var mouseDown = false;
		
		var running = false;
		var paused = false;
		
		var fullscreen = false;
		
		var menuUp = false;
		
		var clipboard;
		
		var scenes = [];
		
		var defaultSceneScript = "function update() {\n    S7.clear();\n    this.draw();\n}";
		
		var globalVariables = [];
		var variableTimeout;
		
		var objects = [];
		
		var menusDisabled = false;
		
		var selectedImage;
		var previewImg = document.getElementById("imagePreview");
		
		var savedImages = [];
		
		var currentStoreName;
		
		var database;
		
		var selectedProject;
		
		var projectName;
		
		var newWindow;
		
		var textEditor = document.getElementById("textEditor");
		
		var textArea = document.getElementById("textArea");
		
		var scriptElement = document.getElementById("scriptSelect");
		
		textArea.addEventListener("input", updateCode);
		
		//note width/height are only needed for resize(),
		//ratio is only needed for constrain
		var canvasWidth, canvasHeight, canvasRatio;
		
		var canvasMode;
		
		//setupCanvas(0, 0, "autosize");
		
		showStartMenu();
		
		function setupCanvas(width, height, mode) {
		
			var bg = window.getComputedStyle(document.getElementById('background'));
			
			overlayCanvas.style.width = bg.getPropertyValue("width");
			overlayCanvas.style.height = bg.getPropertyValue("height");
			
			overlayCanvas.width = bg.getPropertyValue("width").slice(0, -2);
			overlayCanvas.height = bg.getPropertyValue("height").slice(0, -2);
			
			if (!mode) {
				canvasMode = "sized";
			} else {
				canvasMode = mode;
			}
			
			if (mode === "constrain") {
				window.addEventListener("resize", resizeConstrain);
				canvasRatio = height / width;
				console.log(height, width, canvasRatio);
				resizeConstrain();
			} else if (mode === "autosize") {
				window.addEventListener("resize", resizeAutosize);
				resizeAutosize();
			} else {
				window.addEventListener("resize", resize);
				canvasWidth = width;
				canvasHeight = height;
				resize();
			}
			
		}
		
		function resize() {
			
			canvas.style.width = canvasWidth + "px";
			canvas.style.height = canvasHeight + "px";
			
			canvas.width = canvasWidth;
			canvas.height = canvasHeight;
			
			drawScene();
		}
		
		function resizeConstrain() {
			var bg = window.getComputedStyle(document.getElementById('background'));
			var maxWidth = parseInt(bg.getPropertyValue("width").slice(0, -2));
			var maxHeight = parseInt(bg.getPropertyValue("height").slice(0, -2));
			
			if (maxWidth * canvasRatio < maxHeight) {
				var width = maxWidth;
				var height = maxWidth * canvasRatio;
			} else {
				var height = maxHeight;
				var width = maxHeight / canvasRatio;
			}
			
			canvas.style.width = width + "px";
			canvas.style.height = height + "px";
			
			canvas.width = width;
			canvas.height = height;
			
			drawScene();
		}
		
		function resizeAutosize() {
			var bg = window.getComputedStyle(document.getElementById('background'));
			
			var width = bg.getPropertyValue("width");
			var height = bg.getPropertyValue("height");
			
			canvas.style.width = width;
			canvas.style.height = height;
			
			canvas.width = width.slice(0, -2);
			canvas.height = height.slice(0, -2);
			
			drawScene();
		}
		
		//Command Pattern system
		
		function History() {
			this.undos = [];
			this.history = [];
			
			this.undo = function() {
				if (this.history.length>0) {
					this.history[this.history.length-1].undo();
					this.undos.push(this.history.pop());
				}
				saveCurrentState2();
			}
			
			this.redo = function() {
				if (this.undos.length>0) {
					this.undos[this.undos.length-1].run();
					this.history.push(this.undos.pop());
				}
				saveCurrentState2();
			}
			
			this.run = function(command) {
				command.run();
				this.history.push(command);
				this.redos = [];
				saveCurrentState2();
			}
			
			this.add = function(command) {
				this.history.push(command);
				this.redos = [];
				saveCurrentState2();
			}
		}
		
		function ChangePositionCommand (object, origPosX, origPosY, newPosX, newPosY) {
			this.object = object;
			this.origPosX = origPosX;
			this.origPosY = origPosY;
			this.newPosX = newPosX;
			this.newPosY = newPosY;
			
			this.undo = function() {
				this.object.x = this.origPosX;
				this.object.y = this.origPosY;
				drawScene();
				drawProperties();
			}
			
			this.run = function() {
				this.object.x = this.newPosX;
				this.object.y = this.newPosY;
				drawScene();
				drawProperties();
			}
		}

		function ChangePropertyCommand(object, property, origProp, newProp) {
			this.object = object;
			this.property = property;
			this.origProp = origProp;
			this.newProp = newProp;
			
			this.undo = function() {
				this.object[this.property] = this.origProp;
				drawScene();
				//drawProperties();
			}
			
			this.run = function() {
				this.object[this.property] = this.newProp;
				drawScene();
				//drawProperties();
			}
		}
		
		function ChangeHierachyCommand(object, oldParent, newParent, element,
			oldParentEle, newParentEle, oldIndex, newIndex) {
			
			this.object = object;
			this.oldParent = oldParent;
			this.newParent = newParent;
			this.element = element;
			this.oldParentEle = oldParentEle;
			this.newParentEle = newParentEle;
			this.oldIndex = oldIndex;
			this.newIndex = newIndex;
			
			this.run = function() {
				this.newParent.add(this.object);
				this.newParentEle.appendChild(this.element);
				if (this.newParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
			
			this.undo = function() {
				this.oldParent.add(this.object);
				this.oldParentEle.appendChild(this.element);
				if (this.oldParent.isScene === true) {
					this.element.style.marginLeft = "0px";
				} else {
					this.element.style.marginLeft = "26px";
				}
				//drawSceneOverview();
				drawScene();
			}
		}
		
		function ChangeSizeCommand(object, oldWidth, oldHeight, newWidth, newHeight, oldX, oldY, newX, newY) {
			
			this.object = object;
			if (object.isRectangle === true) {
				this.propertyX = "width";
				this.propertyY = "height";
			}
			if (object.isCircle === true) {
				this.propertyX = "radius";
				this.propertyY = "radius";
			}
			if (object.isEllipse === true) {
				this.propertyX = "radiusX";
				this.propertyY = "radiusY";
			}
			if (object.isText === true) {
				this.propertyX = "fontSize";
				this.propertyY = "fontSize";
			}
			this.oldWidth = oldWidth;
			this.newWidth = newWidth;
			this.oldHeight = oldHeight;
			this.newHeight = newHeight;
			this.oldX = oldX;
			this.oldY = oldY;
			this.newX = newX;
			this.newY = newY;
			
			this.run = function() {
				this.object[this.propertyX] = this.newWidth;
				this.object[this.propertyY] = this.newHeight;
				this.object.x = this.newX;
				this.object.y = this.newY;
				drawScene();
			}
			
			this.undo = function() {
				this.object[this.propertyX] = this.oldWidth;
				this.object[this.propertyY] = this.oldHeight;
				this.object.x = this.oldX;
				this.object.y = this.oldY;
				drawScene();
			}
		}
		
		var _history = new History();
		
		document.getElementById('newProjectButton').addEventListener('click', newProject);
		
		function newProject() {
			//get values for new project and enter them in setupCanvas()
			
			var newWidth = document.getElementById("newWidth").value;
			var newHeight = document.getElementById("newHeight").value;
			var newAutoSize = document.getElementById("newAutoSize").checked;
			var newConstrain = document.getElementById("newConstrain").checked;
			
			projectName = document.getElementById("newProjectName").value;
			
			if (newConstrain) {
				setupCanvas(newWidth, newHeight, "constrain");
			} else if (newAutoSize) {
				setupCanvas(newWidth, newHeight, "autosize");
			} else {
				setupCanvas(newWidth, newHeight);
			}
			
			newStoreName();
			
			//close menu
			document.getElementById("newMenu").style.display = "none";
		}
		
		var activeScene;
		
		var control;
		
		function defaultCode() {
		
			S7.setCanvas(canvas);
			
			control = new S7.Control();
			control.runSpontaneously = false;
			
			var scene = new S7.Scene();
			scene.addScript(defaultSceneScript, 'default');//default code to be run in the scene
			
			scenes.push(scene);
			
			activeScene = scene;
		}
		defaultCode();
		
		var selectedObject;
		
		var selectedElement;
		
		function testCode() {
		
			var circ = new S7.Circle(350, 100, 60);
			activeScene.add(circ);
			
			var rect = new S7.Rectangle(30, 300, 100, 50);
			rect.rotation = 1;
			activeScene.add(rect);
			rect.addScript(textArea.value);	
			addScriptOption(rect.scripts[0]);
			
			rect.addScript(`function start() {\n    this.fill = true;\n    this.fillColour = "green";\n}`);
			addScriptOption(rect.scripts[1]);
			//add that script
			
			selectedObject = rect;
			
			var rect2 = new S7.Rectangle(50, 100, 100, 50);
			
			rect2.name = "fireRect";
			rect2.fill = true;
			rect2.fillColour = "#FF0000";
			
			activeScene.add(rect2);
			
			var rect3 = new S7.Rectangle(10, 10, 50, 20);
			rect3.name = "testRecto";
			rect2.add(rect3);
			
			var text = new S7.Text("Hello!", 500, 300);
			text.fontSize = 40;
			text.rotation = 0;
			activeScene.add(text);
			
			var image = new S7.Sprite();
			activeScene.add(image);
			selectedObject = image;
			
			objects.push(image, text, rect, rect2, rect3, circ, activeScene);
		
		}
		
		//testCode();
		
		drawScene();
		
		//DEFINING PROPERTIES FOR EACH OBJECT
		
		function drawProperties() {
		
			var propertiesElement = document.getElementById('properties');
			
			if (!selectedObject) {
				
				document.getElementById("propertiesTitle").innerHTML = "No object selected";
				return "";
			}
			
			updatePropertiesName();
						
			//remove all current stuff in properties
			
			var currProperties = document.getElementsByClassName("propertyColumn");
			var propLength = currProperties.length;
			for (var i=0;i<propLength;i++) {
				propertiesElement.removeChild(currProperties[0]);
			}
			
			//decide how many columns to have based on the selected object
			
			var numOfColumns = 3;
			
			//column 1 is x, y, size, rotation stuff
			
			//column 2 is fill/stroke and visiblity colour stuff
			
			//column 3 is name and misc
			
			//[name of property, size]
			
			var properties = [];
			
			class Property {
				constructor(name, size, column, type, displayName) {
					this.name = name;
					this.size = size;
					this.column = column;
					this.type = type;
					this.displayName = displayName;
					properties.push(this);
				}
			}
			
			new Property("x", 1, 1, "number", "x"), 
			new Property("y", 1, 1, "number", "y"),
			new Property("width", 1, 1, "number", "width"),
			new Property("height", 1, 1, "number", "height"),
			new Property("radius", 1, 1, "number", "radius"), 
			new Property("radiusX", 1, 1, "number", "radiusX"),
			new Property("radiusY", 1, 1, "number", "radiusY"),
			new Property("zoomX", 1, 1, "number", "X-Zoom"),
			new Property("zoomY", 1, 1, "number", "Y-Zoom"),
			new Property("rotation", 1, 1, "angle", "rotation"),
			new Property("string", 3, 1, "text", "string"), 
			new Property("fontSize", 1, 1, "number", "Font Size"),
			new Property("fill", 3, 2, "boolean", "fill"), 
			new Property("fillColour", 4, 2, "colour", "Fill Colour"),
			new Property("stroke", 3, 2, "boolean", "stroke"), 
			new Property("strokeColour", 3, 2, "colour", "Stroke Colour"),
			new Property("strokeSize", 1, 2, "number", "Stroke Size"), 
			new Property("visible", 3, 3, "boolean", "visible"),
			new Property("opacity", 2, 3, "number", "opacity"), 
			new Property("name", 10, 3, "text", "name");
			new Property("url", 4, 2, "image", "url");
			
			for (var j=0;j<numOfColumns;j++) {
				var column = document.createElement("DIV");
				column.className = "propertyColumn";
				column.style.width = 100 / numOfColumns + "%";
				
				for (var i=0;i<properties.length;i++) {
					if (selectedObject[properties[i].name] !== undefined && properties[i].column === j+1) {
						//work out what input is necessary
						
						let myinput = document.createElement("INPUT");
						
						myinput.className = "properties";
						
						myinput.property = properties[i].name;
						myinput.propertyType = properties[i].type;
						
						if (myinput.propertyType === "number" || myinput.propertyType === "text" || myinput.propertyType === "angle") {
							myinput.type = 'text';
						
							myinput.setAttribute("value", selectedObject[properties[i].name]);
							
							myinput.style.textAlign = "center";
							myinput.setAttribute("size", properties[i].size);
							
							myinput.addEventListener('input', updateProperties);
							
							
						}
						
						if (myinput.propertyType === "colour") {
							myinput.type = 'color';
							myinput.setAttribute("value", selectedObject[properties[i].name]);
							
							myinput.addEventListener('input', updateProperties);
						}
						
						if (myinput.propertyType === "boolean") {
							myinput.type = 'checkbox';
							
							if (selectedObject[properties[i].name] === true) {
								myinput.checked = true;
							}
							
							myinput.addEventListener('change', updateProperties);
						}
						
						if (myinput.propertyType === "image") {
							myinput.type = "button"
							
							if (selectedObject[properties[i].name] === "") {
								myinput.value = "No Image";
							} else {
								myinput.value = selectedObject[properties[i].name];
							}
							myinput.addEventListener('click', chooseImage);
							
							myinput.style.padding = properties[i].size + "px";
						}
						
						//can't use innerHTML directly on properties because it overwrites event listeners
						let text = document.createElement("SPAN");
						text.innerHTML += "<br>" + properties[i].name + ": ";
						column.appendChild(text);
						
						column.appendChild(myinput);
						
						if (myinput.propertyType === "angle") {
							let angleTypeButton = document.createElement("BUTTON");
							
							angleTypeButton.innerHTML = selectedObject[properties[i].name + "AngleMode"];
							//console.log(properties, "AngleMode", selectedObject[properties + "AngleMode"]);
							angleTypeButton.property = properties[i].name;
							
							angleTypeButton.addEventListener('click', changeAngleType);
							
							column.appendChild(angleTypeButton);
						}
					}
				}
				propertiesElement.appendChild(column);
				
				
			}
			
		}
		drawProperties();
		
		function changeAngleType(e) {
			selectedObject.changeAngleType(e.srcElement.property);
			drawProperties();
		}
		
		function updatePropertiesName() {
			document.getElementById("propertiesTitle").innerHTML = "Properties for " + selectedObject.name;
		}
		
		function updateProperties(e) {
			switch(e.srcElement.propertyType) {
				
				case "angle":
				case "number":
					if (!isNaN(e.srcElement.value) && e.srcElement.value !== "") {
						_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property,
							selectedObject[e.srcElement.property], parseFloat(e.srcElement.value)));
						//selectedObject[e.srcElement.property] = parseFloat(e.srcElement.value);
						//drawScene();
					}
					break;
				
				case "boolean":
					
					//parse as boolean
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.checked));
					//selectedObject[e.srcElement.property] = e.srcElement.checked;
					//drawScene();
					break;
				
				case "colour":
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					//drawScene();
					break;
				
				case "text":
					
					//selectedObject[e.srcElement.property] = e.srcElement.value;
					
					if (e.srcElement.property === "name") {
						if (!isLegalVariable(e.srcElement.value)) {
							e.srcElement.style.backgroundColor = "#FF4444";
							return "";
						}
						
						e.srcElement.style.backgroundColor = "#FFFFFF";
					}
					
					_history.run(new ChangePropertyCommand(selectedObject, e.srcElement.property, 
						selectedObject[e.srcElement.property], e.srcElement.value));
					
					if (e.srcElement.property === "name") {
						if (selectedObject.isScene === true) {
							drawProjectOverview();
						} else {
							updatePropertiesName();
							drawSceneOverview();
						}
					}
					break;
					
				default:
					console.warn("property type wrong?", e.srcElement.propertyType);
				
			}
		}
		
		//END OF PROPERTIES
		
		var elementDragged;
		
		function drawSceneOverview() {
			var sceneOverview = document.getElementById("sceneOverview");
			//do current scene first
			var currScene = document.getElementById("currentScene");
			
			//clear sceneoverview first
			while (currScene.children.length>0) {
				currScene.removeChild(currScene.children[0]);
			}
			
			currScene.addEventListener("dragover", function(e) {
				e.preventDefault();
			});
				
			currScene.addEventListener("drop", function(e) {
				e.preventDefault();
				
				if (changedScene === false) {
					_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
						activeScene, elementDragged, elementDragged.parentElement, currScene));
					/*elementDragged.parentElement.removeChild(elementDragged);
							
					currScene.appendChild(elementDragged);
					
					activeScene.add(elementDragged.object);
					
					//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
					elementDragged.style.marginLeft = "0px"
					drawScene();*/
				}
			});
			
			for (var i=0;i<activeScene.children.length;i++) {
				addElement(activeScene.children[i]);
				function addElement(object) {
				
					let DOMElement = document.createElement("SPAN");
					
					DOMElement.innerHTML = object.name + "<br>";
					
					DOMElement.className = "sceneChild";
					
					DOMElement.object = object;
					
					DOMElement.draggable = true;
					
					DOMElement.style.border = "solid 1px white";
					
					if (object === selectedObject) {
						selectedElement = DOMElement;
						DOMElement.style.color = SELECTED_TEXT_COLOR;
						DOMElement.style.backgroundColor = SELECTED_BACKGROUND_COLOR;
					}
					
					DOMElement.addEventListener("mouseover", function(e) {
						if (menusDisabled === false) {
							e.target.style.border = "dashed 1px black";
						}
					});
					
					DOMElement.addEventListener("mouseout", function(e) {
						e.target.style.border = "solid 1px white";
					});
					
					DOMElement.addEventListener("click", function(e) {
						if (menusDisabled === false) {
							selectObject(e.target.object);
						}
					});
					
					DOMElement.addEventListener("dragstart", function(e) {
						if (menusDisabled === false) {
							elementDragged = e.target;
							if (e.target.style.border !== "1px solid black") {
								e.target.style.border = "double 1px black";
							}
							//console.log(e.target.innerHTML);
							changedScene = false;
						}
					});
					
					DOMElement.addEventListener("dragover", function(e) {
						e.preventDefault();
					});
					
					DOMElement.addEventListener("dragend", function(e) {
						DOMElement.style.border = "solid 1px white";
						//console.log(DOMElement.className);
					});
					
					DOMElement.addEventListener("drop", function(e) {
						e.preventDefault();
						changedScene = true;
						//prevent childing self and to child
						if (elementDragged !== e.target && !isRelated(elementDragged, e.target)) {
							//e.target.add(elementDragged);//fix this
							_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
								e.target.object, elementDragged, elementDragged.parentElement, e.target));
							/*elementDragged.parentElement.removeChild(elementDragged);
							
							e.target.appendChild(elementDragged);
							
							e.target.object.add(elementDragged.object);
							
							//elementDragged.insertAdjacentHTML("beforebegin", "&emsp;");
							elementDragged.style.marginLeft = "26px"
							drawScene();*/
						}
					});
					
					addChildren(DOMElement);
					
					if (object.parent.constructor.name === "Scene") {
						currScene.appendChild(DOMElement);
					} else {
						return DOMElement;
					}
					
					function addChildren(element) {
						for (var i=0;i<element.object.children.length;i++) {
							var ele = addElement(element.object.children[i]);
							if (ele !== undefined) {
								ele.style.marginLeft = "26px";
								element.appendChild(ele);
							}
						}
					}
				}
			}
		}
		drawSceneOverview();
		
		function drawProjectOverview() {
			var projectOverview = document.getElementById("projectOverview");
			
			var scenesEle = document.getElementById('scenesOverview');
			
			//clear projectoverview first
			while (scenesEle.children.length>0) {
				scenesEle.removeChild(scenesEle.children[0]);
			}
			
			scenesEle.addEventListener("dragover", function(e) {
				e.preventDefault();
				
				//e.clientY
					
				var height = scenesEle.children[0].getBoundingClientRect().height;
				
				var num = Math.floor((e.clientY + scenesEle.scrollTop) / height);
				
				if (scenesEle.children[num] !== elementDragged) {
					if (elementDragged.index > num) {
						scenesEle.insertBefore(elementDragged, scenesEle.children[num]);
					} else {
						scenesEle.insertBefore(elementDragged, scenesEle.children[num].nextSibling);
					}
					//fix index and order of array
					scenes.splice(elementDragged.index, 1);
					scenes.splice(num, 0, elementDragged.scene);
					
					for (var i=0;i<scenesEle.children.length;i++) {
						scenesEle.children[i].index = i;
					}
				}
				
				
			});
				
			scenesEle.addEventListener("drop", function(e) {
				e.preventDefault();
				
				/*if (changedScene === false) {
					_history.run(new ChangeHierachyCommand(elementDragged.object, elementDragged.object.parent, 
						activeScene, elementDragged, elementDragged.parentElement, currScene));
				}*/
			});
			
			for (var i=0;i<scenes.length;i++) {
				addElement(scenes[i]);
				function addElement(scene) {
				
					let DOMElement = document.createElement("SPAN");
					
					DOMElement.innerHTML = scene.name + "<br>";
					
					DOMElement.className = "projectChild";
					
					DOMElement.scene = scene;
					
					DOMElement.index = i;
					
					DOMElement.draggable = true;
					
					DOMElement.style.border = "1px solid white";
					
					if (scene === selectedObject) {
						selectedElement = DOMElement;
						DOMElement.style.color = SELECTED_TEXT_COLOR;
						DOMElement.style.backgroundColor = SELECTED_BACKGROUND_COLOR;
					}
					
					DOMElement.addEventListener("mouseover", function(e) {
						if (menusDisabled === false) {
							e.target.style.border = "dashed 1px black";
						}
					});
					
					DOMElement.addEventListener("mouseout", function(e) {
						e.target.style.border = "1px solid white";
					});
					
					DOMElement.addEventListener("click", function(e) {
						if (menusDisabled === false) {
							activeScene = e.target.scene;
							selectObject(e.target.scene);
							drawScene();
							e.target.style.backgroundColor = "green";
						}
					});
					
					DOMElement.addEventListener("dragstart", function(e) {
						if (menusDisabled === false) {
							elementDragged = e.target;
							if (e.target.style.border !== "1px solid black") {
								e.target.style.border = "double 1px black";
							}
							//e.target.parentElement.removeChild(e.target);
							changedScene = false;
						}
					});
					
					DOMElement.addEventListener("dragover", function(e) {
						e.preventDefault();
						
						
					});
					
					DOMElement.addEventListener("dragend", function(e) {
						DOMElement.style.border = "initial";
					});
					
					DOMElement.addEventListener("drop", function(e) {
						e.preventDefault();
						changedScene = true;

					});
					
					scenesEle.appendChild(DOMElement);
					
				}
			}
		}
		drawProjectOverview();
		
		document.getElementById('newSceneButton').addEventListener('click', newScene);
		
		function newScene() {
			var temp = new S7.Scene();
			temp.addScript(defaultSceneScript, 'default');
			scenes.push(temp);
			activeScene = temp;
			selectObject(temp);
			drawScene();
			drawProjectOverview();
		}
		
		document.getElementById('deleteSceneButton').addEventListener('click', deleteScene);
		
		function deleteScene() {
			if (scenes.length > 1) {
				var i = scenes.indexOf(activeScene);
				for (var j=0;j<activeScene.children.length;j++) {
					delete activeScene.children[j];
				}
				scenes.splice(i, 1);
				
				activeScene = scenes[i-1];
				selectObject(activeScene);
			}
			drawProjectOverview();
			drawProperties();
			drawScene();
		}
		
		function getVariableName(e) {
			console.log(e, globalVariables[e.target.index]);
		}
		
		function getVariableValue(e) {
			globalVariables[e.target.index][1] = e.target.value;
		}
		
		function drawVariableOverview() {
			var variableNamesElement = document.getElementById('varNames');
			var variableValuesElement = document.getElementById('varValues');
			
			while (variableNamesElement.children.length>0) {
				variableNamesElement.removeChild(variableNamesElement.children[0]);
			}
			
			while (variableValuesElement.children.length>0) {
				variableValuesElement.removeChild(variableValuesElement.children[0]);
			}
			
			for (var i=0;i<globalVariables.length;i++) {
				var nameElement = document.createElement("INPUT");
				nameElement.type = "text";
				nameElement.value = globalVariables[i][0];
				nameElement.index = i;
				nameElement.addEventListener('input', getVariableName);
				nameElement.className = "varBoxes";
				
				variableNamesElement.appendChild(nameElement);
				
				var valueElement = document.createElement("INPUT");
				valueElement.index = i;
				valueElement.addEventListener('input', getVariableValue);
				valueElement.className = "varBoxes";
				
				variableValuesElement.appendChild(valueElement);
				//console.log(temp, globalVariables);
			}
		}
		
		document.getElementById('addVariableButton').addEventListener('click', addVariable);
		
		function addVariable() {
			var variableArea = document.getElementById('variableName');
			var variableName = variableArea.value
			var regexTest = RegExp('^[0-9]|\\s');
			
			if (window[variableName] || regexTest.test(variableName)) {
				
				variableArea.className = "failAnimation";
				if (variableTimeout) {
					clearTimeout(variableTimeout);
					
					var area = document.createElement("TEXTAREA");
					area.id = "variableName";
					area.className = "failAnimation";
					//area.type = "text";
					area.placeholder = "Variable Name";
					area.value = variableName;
					variableArea.id="";
					var parentVarEle = document.getElementById('addVariables')
					parentVarEle.removeChild(variableArea);
					parentVarEle.appendChild(area);
					variableArea = area;
				}
				
				variableTimeout = setTimeout(function() {
					variableArea.className = "";
					variableTimeout = undefined;
				}, 2000);
				
				
			} else {
				//variable passed test
				globalVariables.push([variableName, ""]);
				variableArea.value = "";
				drawVariableOverview();
			}
		}
		
		function chooseImage(e) {
			if (e.target.property === "url") {
				drawImageMenu();
			}
		}
		
		function drawImageMenu() {
			var menu = document.getElementById("imageMenu");
			menu.style.display = "block";
			disableMenus();
			drawBrowser();
		}
		
		document.getElementById('useImageButton').addEventListener('click', loadImage);
		
		function loadImage() {
			selectedObject.setImage(selectedImage[0]);
			selectedObject.url = selectedImage[1];
			var menu = document.getElementById("imageMenu");
			menu.style.display = "none";
			enableMenus();
			if (selectedObject.loaded === true) {
				drawProperties();
				drawScene();
			} else {
				selectedObject.image.onload = function() {
					drawProperties();
					drawScene();
				}
			}
		}
		
		document.getElementById('importImageButton').addEventListener('change', importImage);
		
		function importImage() {
			var imageEle = document.getElementById("importImageButton");
			
			var filereader = new FileReader();
			filereader.readAsDataURL(imageEle.files[0]);
			filereader.onload = function() {
				addImage(filereader.result, imageEle.files[0].name);
				drawBrowser();
			};
		}
		
		function addImage(img, fileName) {
			//img url, filename, index
			savedImages.push([img, fileName, savedImages.length]);
			selectedImage = savedImages[savedImages.length-1];
			
			previewImg.src = img;
		}
		
		function drawBrowser() {
			//each column is 128px across
			
			var browser = document.getElementById("imageBrowser");
			
			var maxWidth = parseFloat(window.getComputedStyle(browser).getPropertyValue('width'));
			
			
			while(browser.children.length>0) {
				browser.removeChild(browser.children[0]);
			}
			
			var tempRow = document.createElement("DIV");
			
			var i=0;
			
			for (var j=0;j<savedImages.length;j++) {
				//each box is 156 x 156
				//image preview is 128 x 128
				
				//create rows as long as there are images to load
				
				if ((j+1-i) * 156 > maxWidth) {
					console.log(i, j);
					i+=j;
					browser.appendChild(tempRow);
					tempRow = document.createElement("DIV");
				}
				
				var imageBox = document.createElement("FIGURE");
				imageBox.className = "imageBox";
				
				var image = document.createElement("IMG");
				image.className = "previewIcon";
				image.src = savedImages[j][0];
				image.fileName = savedImages[j][1];
				image.index = j;
				//image
				
				var caption = document.createElement("FIGCAPTION");
				caption.innerHTML = image.fileName;
				caption.className = "imageCaption";
				
				imageBox.appendChild(image);
				imageBox.appendChild(caption);
				tempRow.appendChild(imageBox);
				
				if (selectedImage) {
					if (selectedImage[2] === j) {
						imageBox.style.backgroundColor = "#0022FF";
						imageBox.children[1].style.color = "#FFFFFF";
					}
				}
				
				imageBox.addEventListener("click", function(e) {
					
					//clear selectedImage first
					
					if (selectedImage) {
						var index = selectedImage[2];
						
						var row = Math.floor(((index+1) * 156) / maxWidth);
						var ele = ((((index+1) * 156) % maxWidth) / 156) - 1;
						console.log(row, ele, index, browser);
						var element = browser.children[row].children[ele];
						element.style.backgroundColor = "#FFFFFF";
						element.children[1].style.color = "#000000";
					}
					
					this.style.backgroundColor = "#0022FF";
					this.children[1].style.color = "#FFFFFF";
					
					selectedImage = savedImages[this.children[0].index];
					
					previewImg.src = selectedImage[0];
				});
				
			}
			browser.appendChild(tempRow);
		}
		
		function selectObject(object) {
			if (selectedElement) {
				selectedElement.style.backgroundColor = "white";
				selectedElement.style.color = "black";
			}
			selectedObject = object;
			
			drawProperties();
			drawScaleOverlay();
			drawProjectOverview();
			
			scriptElement.value = 0;
			
			//fix script
			while (scriptElement.children.length>0) {
				scriptElement.removeChild(scriptElement.children[0]);
			}
			
			for(var i=0;i<selectedObject.scripts.length;i++) {
				addScriptOption(selectedObject.scripts[i]);
			}
			
			drawSceneOverview();
			
			if (selectedElement) {
				selectedElement.style.backgroundColor = SELECTED_BACKGROUND_COLOR;
				selectedElement.style.color = SELECTED_TEXT_COLOR;
			}
			
			scriptChange();
		}
		
		document.getElementById('addRect').addEventListener('click', function() {addObject("Rectangle")});
		document.getElementById('addCircle').addEventListener('click', function() {addObject("Circle")});
		document.getElementById('addEllipse').addEventListener('click', function() {addObject("Ellipse")});
		document.getElementById('addText').addEventListener('click', function() {addObject("Text")});
		document.getElementById('addSprite').addEventListener('click', function() {addObject("Sprite")});
		
		function addObject(type) {
			var temp = new S7[type]();
			activeScene.add(temp);
			objects.push(temp);
			selectObject(temp);
			drawScene();
			drawSceneOverview();
		}
		
		document.getElementById('deleteButton').addEventListener('click', deleteObject);
		
		function deleteObject() {
			activeScene.remove(selectedObject);
			selectedObject = activeScene;
			drawScene();
			drawSceneOverview();
			drawProperties();
		}
		
		function isRelated(element, element2) {
			for (var i=0;i<element.children.length;i++) {
				if (element2 === element.children[i]) {
					return true;
				}
			}
			for (var i=0;i<element2.children.length;i++) {
				if (element === element2.children[i]) {
					return true;
				}
			}
			return false;
		}
		
		function drawScene() {
			canvas.style.left = sceneOffsetX + "px";
			canvas.style.top = sceneOffsetY + "px";
			canvas.style.backgroundColor = "white";
			
			S7.clear();
			
			activeScene.draw();
			
			drawScaleOverlay();
		}
		
		//overlayCanvas.addEventListener('wheel', zoom);
		
		function zoom(e) {
			e.preventDefault();
			
			var zoomAmount;
			if (e.deltaY > 0) {
				zoomAmount = 0.5;
				//activeScene.zoom(0.5, 0.5, e.offsetX, e.offsetY);
			} else {
				zoomAmount = 2;
				//activeScene.zoom(2, 2, e.offsetX, e.offsetY);
			}
			
			activeScene.zoom(zoomAmount, zoomAmount, e.offsetX, e.offsetY);
			zoomX *= zoomAmount;
			zoomY *= zoomAmount;
			
			drawProperties();
			drawScene();
		
		}

		textArea.addEventListener('keydown', function(e) {
			if (e.key === "Tab") {
				e.preventDefault();
				var caretStart = textArea.selectionStart;
				var caretEnd = textArea.selectionEnd;
				textArea.value = textArea.value.substring(0, caretStart) + "    " + textArea.value.substring(caretEnd);
				textArea.selectionEnd = textArea.selectionStart = caretStart + 4;
			}
		});
		
		document.addEventListener('keydown', keyDown);
		
		function keyDown(e) {
			if (e.key === "z" && e.ctrlKey === true) {
				_history.undo();
			}
			if (e.key === "y" && e.ctrlKey === true) {
				_history.redo();
			}
			if (e.key === "s" && e.ctrlKey === true) {
				e.preventDefault();
				saveCurrentState2();
			}
		}
		
		document.addEventListener('mousedown', function(e) {
			mouseDown = true;
		});
		
		document.addEventListener('mouseup', mouseRelease);
		
		function mouseRelease(e) {
			mouseDown = false;
			
			if (!selectedObject) {
				return "";
			}
			
			if (objectDragged === "object") {
				_history.add(new ChangePositionCommand(selectedObject, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
			} else if (objectDragged !== true && objectDragged !== false && objectDragged !== "scene") {
				
				if (selectedObject.isRectangle === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.width, 
						selectedObject.height, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
					
				}
				if (selectedObject.isCircle === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.radius,
						selectedObject.radius, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
				}
				if (selectedObject.isEllipse === true) {
					_history.add(new ChangeSizeCommand(selectedObject, objectSizeX, objectSizeY, selectedObject.radiusX,
						selectedObject.radiusY, objectPosX, objectPosY, selectedObject.x, selectedObject.y));
				}
			}
			objectDragged = "";
			if (overlayCanvas.style.cursor === "-webkit-grabbing") {
				overlayCanvas.style.cursor = "-webkit-grab";
			}
		}
		
		document.addEventListener('dragend', function(e) {
			mouseDown = false;
			objectDragged = "";
		});
		
		overlayCanvas.addEventListener('mousedown', mousePressed);
		canvas.addEventListener('mousedown', mousePressed);
		
		function mousePressed(e) {
			if (menusDisabled === false) {
				if (selectedObject) {
					var result = mouseOnOverlay(e.offsetX, e.offsetY);
				} else {
					var result = false;
				}
				
				switch(result) {
					case true:
						objectDragged = "object";
						overlayCanvas.style.cursor = "-webkit-grabbing";
						var realDims = selectedObject.getRealProperties();
						objectPosX = realDims.x;
						objectPosY = realDims.y;
						break;
						
					case false:
						//using e.offsetX and e.offsetY
						var descendents = activeScene.getAllDescendents();
						var selectedSomething = false;
						for (var i=0;i<descendents.length;i++) {
							//var dims = {x: descendents[i].x * zoomX, y: descendents[i].y * zoomY, rotation: descendents[i].rotation};
							var dims = {x: 0, y: 0, rotation: 0};
							var realDims = descendents[i].getRealProperties();
							
							dims.x += realDims.x + sceneOffsetX * zoomX;
							dims.y += realDims.y + sceneOffsetY * zoomY;
							dims.rotation += realDims.rotation;
							
							var selected = false;
							
							var objectWidth;
							var objectHeight;
							
							if (descendents[i].isRectangle === true || descendents[i].isSprite === true ||
								descendents[i].isText === true) {
								
								if (descendents[i].isText === true) {
									objectWidth = descendents[i].getWidth() * zoomX;
									objectHeight = descendents[i].getHeight() * zoomY;
								}
							
								if (descendents[i].isRectangle === true || descendents[i].isSprite === true) {
									objectWidth = descendents[i].width * zoomX;
									objectHeight = descendents[i].height * zoomY;
								}
								
								//rotate
								
								var newX = e.offsetX - (dims.x + objectWidth/2);
								var newY = e.offsetY - (dims.y + objectHeight/2);
								
								var newMouseX = newX * Math.cos(-dims.rotation) - newY * Math.sin(-dims.rotation);
								var newMouseY = newX * Math.sin(-dims.rotation) + newY * Math.cos(-dims.rotation);
								
								var mouseX = newMouseX + dims.x + objectWidth/2;
								var mouseY = newMouseY + dims.y + objectHeight/2;
								
								if (mouseX >= dims.x && mouseY >= dims.y &&
									mouseX <= dims.x + objectWidth &&
									mouseY <= dims.y + objectHeight) {
									
									selected = true;
								}
							}
									
							if (descendents[i].isCircle === true) {
								if (Math.hypot(Math.abs(e.offsetX - dims.x) * zoomX, Math.abs(e.offsetY - dims.y) * zoomY) <= descendents[i].radius) {
									selected = true;
								}
							}
							
							if (descendents[i].isEllipse === true) {
								if (descendents[i].radiusY ** 2 * ((e.offsetX - dims.x) ** 2) + 
									descendents[i].radiusX ** 2 * ((e.offsetY - dims.y) ** 2) <= 
									descendents[i].radiusX ** 2 * descendents[i].radiusY ** 2) {
									
									selected = true;
								}
							}
							
							if (selected === true) {
								selectObject(descendents[i]);
								objectDragged = "object";
								overlayCanvas.style.cursor = "-webkit-grabbing";
								selectedSomething = true;
								objectPosX = descendents[i].x;
								objectPosY = descendents[i].y;
							}
						}
						if (selectedSomething === false) {
							selectObject(activeScene);
							objectDragged = "scene";
							overlayCanvas.style.cursor = "-webkit-grabbing";
							selectedSomething = true;
							
						}
						break;
						
					default:
						objectDragged = result;
						if (selectedObject.isRectangle === true || selectedObject.isSprite === true) {
							objectSizeX = selectedObject.width;
							objectSizeY = selectedObject.height;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isCircle === true) {
							objectSizeX = selectedObject.radius;
							objectSizeY = selectedObject.radius;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isEllipse === true) {
							objectSizeX = selectedObject.radiusX;
							objectSizeY = selectedObject.radiusY;
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						if (selectedObject.isText === true) {
							objectSizeX = selectedObject.getWidth();
							objectSizeY = selectedObject.getHeight();
							objectPosX = selectedObject.x;
							objectPosY = selectedObject.y;
						}
						break;

				}
			}
		}

		function drawScaleOverlay() {
			//using separate canvas for this
			if (!selectedObject) {
				return "";
			}
			
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
			
			//draw overlay
			
			var POINT_OFFSET = 10;
			
			if (selectedObject.stroke === true) {
				POINT_OFFSET += selectedObject.strokeSize/2;
			}
			
			squareSize = 7;
			
			overlayCtx.save();
			
			//var selectedDims = {x: selectedObject.x * zoomX, y: selectedObject.y * zoomY, rotation: selectedObject.rotation};
			var selectedDims = {x: 0, y: 0, rotation: 0};
			var realDims = selectedObject.getRealProperties();
			
			selectedDims.x += realDims.x + sceneOffsetX * zoomX;
			selectedDims.y += realDims.y + sceneOffsetY * zoomY;
			selectedDims.rotation += realDims.rotation;
			
			if (selectedObject.rotationAngleMode === "DEG") {
				selectedDims.rotation *= Math.PI / 180;
			}
			
			if (selectedObject.isRectangle === true || selectedObject.isSprite === true) {
				selectedDims.width = selectedObject.width * zoomX;
				selectedDims.height = selectedObject.height * zoomY;
			}
			if (selectedObject.isCircle === true) {
				selectedDims.x -= selectedObject.radius * zoomX;
				selectedDims.y -= selectedObject.radius * zoomY;
				selectedDims.width = selectedObject.radius * 2 * zoomX;
				selectedDims.height = selectedObject.radius * 2 * zoomY;
				
			}
			if (selectedObject.isEllipse === true) {
				selectedDims.x -= selectedObject.radiusX * zoomX;
				selectedDims.y -= selectedObject.radiusY * zoomY;
				selectedDims.width = selectedObject.radiusX * 2 * zoomX;
				selectedDims.height = selectedObject.radiusY * 2 * zoomY;
				
			}
			
			if (selectedObject.isText === true) {
				selectedDims.width = selectedObject.getWidth() * zoomX;
				selectedDims.height = selectedObject.getHeight() * zoomY;
			}
			
			overlayCtx.translate(selectedDims.x + selectedDims.width/2,
				selectedDims.y + selectedDims.height/2);
			
			overlayCtx.rotate(selectedDims.rotation);
			
			var dims = {};
			
			dims.left = -selectedDims.width/2 - POINT_OFFSET;
			dims.right = selectedDims.width/2 + POINT_OFFSET;
			dims.top = -selectedDims.height/2 - POINT_OFFSET;
			dims.bottom = selectedDims.height/2 + POINT_OFFSET;
			
			points = {};
			//put these into points because then can be used later
			points.topLeft = {x: dims.left, y: dims.top};
			points.topCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.top};
			points.topRight = {x: dims.right, y: dims.top};
			points.centreRight = {x: dims.right, y: (dims.top-dims.bottom)/2 - dims.top};
			points.bottomRight = {x: dims.right, y: dims.bottom};
			points.bottomCentre = {x: (dims.right-dims.left)/2 + dims.left, y: dims.bottom};
			points.bottomLeft = {x: dims.left, y: dims.bottom};
			points.centreLeft = {x: dims.left, y: (dims.top-dims.bottom)/2 - dims.top};

			
			overlayCtx.beginPath();
			
			for (var i in points) {
				
				overlayCtx.rect(points[i].x - squareSize/2, points[i].y - squareSize/2,
					squareSize, squareSize);
					
			}
			
			overlayCtx.moveTo(points.topLeft.x, points.topLeft.y);
			for (var i in points) {
				overlayCtx.lineTo(points[i].x, points[i].y);
			}
			
			
			
			overlayCtx.restore();
			
			overlayCtx.closePath();
			overlayCtx.stroke();
			
			//useful later
			pointsObject = {x: selectedDims.x, y: selectedDims.y, 
				width: selectedDims.width, height: selectedDims.height, rotation: selectedDims.rotation};
		}
		
		overlayCanvas.addEventListener('mousemove', mouseMove);
		canvas.addEventListener('mousemove', mouseMove);
		
		function mouseMove(e) {
			//again use offsetX and offsetY
			if (menusDisabled === false) {
				//remove selections so dragging isn't messed up
				if (window.getSelection) {
					window.getSelection().removeAllRanges();
				} else if (document.selection) {
					document.selection.empty();
				}
				
				mousePosX = e.offsetX;
				mousePosY = e.offsetY;
				
				var coordText = document.getElementById('coords');
				coordText.innerHTML = "(x: " + mousePosX + ", y: " + mousePosY + ")";
				
				if (!selectedObject) {
					return "";
				}
				
				var dimX;
				var dimY;
				
				var sameAxis = false;
				
				if (selectedObject.isRectangle === true || selectedObject.isSprite === true) {
					dimX = "width";
					dimY = "height";
				}
				if (selectedObject.isCircle === true) {
					dimX = "radius";
					dimY = "radius";
					sameAxis = true;
				}
				if (selectedObject.isEllipse === true) {
					dimX = "radiusX";
					dimY = "radiusY";
				}
				if (selectedObject.isText === true) {
					dimX = "fontSize";
					dimY = "fontSize";
					sameAxis = true;
				}
				
				var changeX = e.movementX / zoomX;
				var changeY = e.movementY / zoomY;
				
				switch(objectDragged) {
					case "object":
						selectedObject.x += changeX;
						selectedObject.y += changeY;
						
						drawScene();
						drawProperties();
						break;
						
					case "scene":
						sceneOffsetX += changeX;
						sceneOffsetY += changeY;
						
						drawScene();
						break;
						
					case "topLeft":
						var diff;

						diff = Math.max(0, selectedObject[dimX] - changeX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						

						diff = Math.max(0, selectedObject[dimY] - changeY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "topCentre":
						var diff = Math.max(0, selectedObject[dimY] - changeY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "topRight":
						if (sameAxis === false) {
							selectedObject[dimX] = Math.max(0, selectedObject[dimX] + changeX);
						} else {
							selectedObject[dimX] = Math.max(0, selectedObject[dimX] + changeX/4);
						}
						var diff = Math.max(0, selectedObject[dimY] - changeY);
						selectedObject.y -= diff - selectedObject[dimY];
						selectedObject[dimY] = diff;
						
						drawScene();
						drawProperties();
						break;
						
					case "centreLeft":
						var diff = Math.max(0, selectedObject[dimX] - changeX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						drawScene();
						drawProperties();
						
						break;
						
					case "bottomLeft":
						var diff = Math.max(0, selectedObject[dimX] - changeX);
						selectedObject.x -= diff - selectedObject[dimX];
						selectedObject[dimX] = diff;
						
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + changeY);
						
						drawScene();
						drawProperties();
						break;
						
					case "bottomCentre":
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + changeY);
						drawScene();
						drawProperties();
						break;
						
					case "bottomRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + changeX);
						selectedObject[dimY] = Math.max(0, selectedObject[dimY] + changeY);
						drawScene();
						drawProperties();
						break;
					
					case "centreRight":
						selectedObject[dimX] = Math.max(0, selectedObject[dimX] + changeX);
						drawScene();
						drawProperties();	
						break;
						
					case "":
						var result = mouseOnOverlay(e.offsetX, e.offsetY);
						switch(result) {
							case "topLeft":
								overlayCanvas.style.cursor = "nw-resize";
								break;
							case "centreLeft":
								overlayCanvas.style.cursor = "w-resize";
								break;
							case "bottomLeft":
								overlayCanvas.style.cursor = "sw-resize";
								break;
							case "bottomCentre":
								overlayCanvas.style.cursor = "s-resize";
								break;
							case "bottomRight":
								overlayCanvas.style.cursor = "se-resize";
								break;
							case "centreRight":
								overlayCanvas.style.cursor = "e-resize";
								break;
							case "topRight":
								overlayCanvas.style.cursor = "ne-resize";
								break;
							case "topCentre":
								overlayCanvas.style.cursor = "n-resize";
								break;
							case true:
									//support for chrome
									overlayCanvas.style.cursor = "-webkit-grab";
									//overlayCanvas.style.cursor = "move";
								break;
							case false:
								overlayCanvas.style.cursor = "auto";
								break;
						}
						break;
				}
			}
		}
		
		function mouseOnOverlay(mouseX, mouseY) {
			
			var newX = mouseX - (pointsObject.x + pointsObject.width/2);
			var newY = mouseY - (pointsObject.y + pointsObject.height/2);
			
			var newMouseX = newX * Math.cos(-pointsObject.rotation) - newY * Math.sin(-pointsObject.rotation);
			var newMouseY = newX * Math.sin(-pointsObject.rotation) + newY * Math.cos(-pointsObject.rotation);
			
			mouseX = newMouseX + pointsObject.x + pointsObject.width/2;
			mouseY = newMouseY + pointsObject.y + pointsObject.height/2;
			
			//checks if on a point
			for (var i in points) {
				var newPointX = points[i].x// * Math.cos(pointsObject.rotation) - points[i].y;
				var newPointY = points[i].y// * Math.sin(pointsObject.rotation) + points[i].x;
				
				if (mouseX >= newPointX + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
					mouseX <= newPointX + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
					mouseY >= newPointY + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
					mouseY <= newPointY + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
						return i;
				}
			}
			//checks if in rectangle
			if (mouseX >= points.centreLeft.x + pointsObject.width/2 + pointsObject.x - squareSize/2 && 
				mouseX <= points.centreRight.x + pointsObject.width/2 + pointsObject.x + squareSize - squareSize/2 &&
				mouseY >= points.topCentre.y + pointsObject.height/2 + pointsObject.y - squareSize/2 && 
				mouseY <= points.bottomCentre.y + pointsObject.height/2 + pointsObject.y + squareSize - squareSize/2) {
					return true;
			}
			return false;
		}
		
		/*
		** EXPORTING/
		** IMPORTING
		*/
		
		function produceDocument() {
			var exportDoc;
			var j;
			
			exportDoc = "\<!DOCTYPE html\>\n";
			exportDoc += "\<html\>\n";
			exportDoc += "\<body\>\n";
			exportDoc += "\<script src='S7.js'\>" + "\</script\>\n";
			exportDoc += "\<script\>\n";
			
			for (var i=0;i<globalVariables.length;i++) {
				exportDoc += "var " + globalVariables[i][0];
				if (globalVariables[i][1] !== undefined && globalVariables[i][1] !== null) {
					exportDoc += " = " + globalVariables[i][1] + ";\n";
				} else {
					exportDoc += ";\n";
				}
			}
			
			exportDoc += "S7.createCanvas();\n";
			
			for (var i=0;i<scenes.length;i++) {
				j=0;
				addText(scenes[i]);
			}
			
			exportDoc += "\</script\>\n";
			exportDoc += "\</body\>\n";
			exportDoc += "\</html\>\n";
			
			function addText(object) {
				j++;
				var name = object.name;
				exportDoc += "var " + name + 
					" = new S7." + object.constructor.name + "();\n";
				
				//make sure only set necessary things
				var base = new object.constructor();
				for (var k in object) {
					if (base[k] !== object[k]) {
						if (k === "children") {
							for (var l=0;l<object.children.length;l++) {
								var tempName = addText(object.children[l]);
								exportDoc += name + ".add(" + tempName + ");\n";
							}
						} else if (k === "scripts") {
							for (var m=0;m<object.scripts.length;m++) {
								exportDoc += name + ".addScript(`" + object.scripts[m].code + "`, \"" + object.scripts[m].name + "\");\n";
							}
						} else if (k === "url") {
							console.log(object);
							exportDoc += name + ".setImage('" + object.image.src + "', true);\n";
						} else if (k !== "parent" && k !== "image" && k !== "loaded" && k !== "currentTransform") {
							if (typeof object[k] === "string") {
								exportDoc += name + "." + k + " = \"" + object[k] + "\";\n";
							} else {
								exportDoc += name + "." + k + " = " + object[k] + ";\n";
							}
						}
					}
				}
				return name;
			}
			return exportDoc;
		}
		
		function getBase64Image(img) {
			var baseCanvas = document.createElement("canvas");
			baseCanvas.width = img.width;
			baseCanvas.height = img.height;
			var baseCtx = baseCanvas.getContext("2d");
			baseCtx.drawImage(img, 0, 0);
			var dataURL = canvas.toDataURL("image/png");
			return dataURL;
		}
		
		/*function toDataURL(url) {
			var xhr = new XMLHttpRequest();
			xhr.onload = function() {
				var reader = new FileReader();
				reader.onloadend = function() {
					return reader.result;
				}
				reader.readAsDataURL(xhr.response);
			};
			xhr.open('GET', url);
			xhr.responseType = 'blob';
			xhr.send();
		}*/
		
		document.getElementById('exportProgramButton').addEventListener('click', exportFile);
		
		function exportFile() {
			var content = produceDocument();
			var fileName = projectName + ".html";
			
			//download(fileName, content);
			var element = document.createElement('a');
			//element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
			element.setAttribute('download', fileName);
		
			element.style.display = 'none';
			document.body.appendChild(element);
		
			element.click();
		
			document.body.removeChild(element);
		}
		
		function readDocument(readDoc) {
			//validateDocument();
			//if (confirm("Your stuff will be overwritten")) {
				var newlineregex = RegExp("\n|;", "g");
				var newlines = [];
				var match;
				
				while (match = newlineregex.exec(readDoc)) {
					newlines.push(match.index);
				}
				
				var variables = [];
				
				for (var i=0;i<newlines.length;i++) {
					if (i===0) {
						var tempString = readDoc.substring(0, newlines[0]);
					} else {
						var tempString = readDoc.substring(newlines[i-1], newlines[i]);
					}
					tempString = tempString.replace(/\s/g, "");
					
					if (tempString.chartAt(0) === "<" || tempString.substring(0, 1) === "//") {
						//skip this
						continue;
					}
					
					if (tempString.substring(0, 2) === "var") {
						if (tempString.indexOf("Scene(")) {
							
						}
					}
				}
				
			//}
		}
		
		function validateDocument(readDoc) {
			//:/
		}
		
		document.getElementById('importButton').addEventListener('change', importFile);
		
		function importFile() {
			var importfile = document.getElementById('importButton');
			console.log(importfile.files);
			var filereader = new FileReader();
			filereader.readAsText(importfile.files[0]);
			filereader.onload = function() {
				readDocument(filereader.result);
			};
		}
		
		function loadCurrentState(str) {
			resetCurrent();
			var lastIndex = 0;
			var index = 0;
			var currentScene;
			var currentObject;
			var child = false;
			var ups = 0;
			while (true) {
				index = str.indexOf(" ", index);
				if (index === -1) {
					break;
				}
				var string = str.substring(lastIndex, index);
				//console.log(index, lastIndex);
				string = string.trim();
				lastIndex = index;
				//console.log(string);
				switch(string) {
					case "sc":
						addNewScene();
						break;
					case "re":
						newObject("Rectangle");
						break;
					case "ci":
						newObject("Circle");
						break;
					case "el":
						newObject("Ellipse");
						break;
					case "sp":
						newObject("Rectangle");
						break;
					case "ba":
						newObject("BaseObject");
						break;
					case "sc":
						newObject("Script");
						break;
					case "gv":
						
						break;
					case "ch":
						//add stuff for children
						child=true;
						/*var nextObj = getNextSubString(index);
						console.log(nextObj);
						var temp = new S7[nextObj]();
						currentObject.add(temp);
						objects.push(temp);
						currentObject = temp;*/
						break;
					case "up":
						ups++;
						break;
					default:
						var value = getNextSubString(index);
						//console.log(currentObject, string, value);
						currentObject[string] = value;
				}
				index++;
			}
			
			function getNextSubString(index2) {
				var newIndex = str.indexOf(" ", index+1);
				var value = str.substring(index2, newIndex);
				
				if (value !== " ") {
					value = value.trim();
					if (!isNaN(parseFloat(value))) {
						return parseFloat(value);
					}
					return value;
				} else {
					return getNextSubString(newIndex);
				}
				
			}
			
			function newObject(type) {
				var temp = new S7[type]();
				if (child === true) {
					currentObject.add(temp);
					child = false;
				} else {
					var parentObj;
					var tempObj = currentObject.parent;
					
					while (ups > 0) {
						tempObj = tempObj.parent;
						ups--;
					}
					tempObj.add(temp);
				}
				objects.push(temp);
				currentObject = temp;
			}
			
			function addNewScene() {
				currentScene = new S7.Scene();
				currentObject = currentScene;
				activeScene = currentScene;
				scenes.push(currentScene);
				selectObject(currentScene);
			}
			drawScene();
			drawSceneOverview();
			drawProperties();
			drawProjectOverview();
		}
		
		function saveCurrentState2() {
			if (!running) {
				openDB(false);
			}
		}
		
		function loadCurrentState2(data) {
			if (data) {
				resetCurrent();
				
				//changing prototypes to what they should be
				
				var newScenes = [];
				
				for (var i=0;i<data.scenes.length;i++) {
					var newScene = convertObj(data.scenes[i]);
					addChildren(data.scenes[i], newScene);
					newScenes.push(newScene);
				}
				
				scenes = newScenes;
				
				activeScene = scenes[0];
				
				globalVariables = data.globalVariables;
				
				switch(data.metadata.sizeData.mode) {
					case "sized":
						setupCanvas(data.metadata.sizeData.width, 
							data.metadata.sizeData.height, data.metadata.sizeData.mode);
						
						break;
						
					case "autosize":
						setupCanvas(0, 0, data.metadata.sizeData.mode);
						
						break;
						
					case "constrain":
						setupCanvas(1, data.metadata.sizeData.ratio, data.metadata.sizeData.mode);
						break;
						
					default:
						console.log(data.metadata.sizeData);
					
				}
				
				drawVariableOverview();
				
				projectName = data.metadata.name;
				
			} else {
				openDB(true);
			}
			
			function convertObj(obj) {
				
				var newObj;
				
				if (obj.isRectangle) {
					newObj = new S7.Rectangle();
				}
				if (obj.isCircle) {
					newObj = new S7.Circle();
				}
				if (obj.isEllipse) {
					newObj = new S7.Ellipse();
				}
				if (obj.isText) {
					newObj = new S7.Text();
				}
				if (obj.isSprite) {
					newObj = new S7.Sprite();
					newObj.setImage(obj.image, true);
				}
				if (obj.isScene) {
					newObj = new S7.Scene();
				}
				
				for (var k in obj) {
					if (k !== "children" && k !== "parent" && k !== "image") {
						newObj[k] = obj[k];
					}
				}
				
				objects.push(newObj);
				
				return newObj;
			}
			
			function addChildren(oldObj, newObj) {
				for (var i=0;i<oldObj.children.length;i++) {
					var newChild = convertObj(oldObj.children[i]);
					newObj.add(newChild);
					addChildren(oldObj.children[i], newChild);
				}
			}
		}
		
		//database structure:
		//db->tables/stores = each project -> {scenes, global variables, metadata}
		
		function openDB(load, version) {
			
			var database;
			
			var openRequest;
			
			//debugger;
			
			if (version) {
				openRequest = indexedDB.open(databaseName, version);
			} else {
				openRequest = indexedDB.open(databaseName);
			}
			
			openRequest.onupgradeneeded = function(e) {
				database = e.target.result;
				
				if (!checkStoreExistence(database, currentStoreName)) {
					
					if (load === true) {
						console.log("cannot load - store doesn't exist");
						openRequest = null;
						return false;
					}
					
					//store doesn't exist yet
					var store = database.createObjectStore(currentStoreName, { autoIncrement: true });
					
					store.createIndex("scenes", "scenes");
					store.createIndex("globalVariables", "globalVariables");
					store.createIndex("metadata", "metadata");
				}
			}
			
			//update current objectstore
			openRequest.onsuccess = function(e) {
				database = e.target.result;
				
				if (checkStoreExistence(database, currentStoreName)) {
					
					if (load === false) {
						//save
						var dataObj = {};
						
						var newScenes = [];

						for (var i=0;i<scenes.length;i++) {
							var tempScene = scenes[i].clone();
							checkObjects(tempScene);
							newScenes.push(tempScene);
						}
						
						function checkObjects(obj) {
							for (var i=0;i<obj.children.length;i++) {
								checkObjects(obj.children[i]);
							}
							if (obj.isSprite) {
								//obj.image = getBase64Image(obj.image);
								obj.image = obj.image.src;
							}
						}

						dataObj.scenes = newScenes;
						
						dataObj.globalVariables = globalVariables;
						
						var sizeData = {mode: canvasMode};
						
						if (canvasMode === "sized") {
							sizeData.width = canvasWidth;
							sizeData.height = canvasHeight;
						}
						
						if (canvasMode === "constrain") {
							sizeData.ratio = canvasRatio;
						}
						
						//low quality because only needs to be small image
						
						S7.clear();
						
						//make background white because jpeg doesn't support transparency
						S7.context.fillStyle = "#FFFFFF";
						S7.context.fillRect(0, 0, canvas.width, canvas.height);
			
						activeScene.draw();
						
						var imgData = canvas.toDataURL("image/jpeg", 0.5);
						
						drawScene();
						
						dataObj.metadata = {sizeData: sizeData, name: projectName, previewImage: imgData};
						
						updateStore(database, currentStoreName, dataObj);
					} else {
						//load data
						loadStore(database, currentStoreName);
					}
				} else {
					
					//have to upgrade the version of the db
					var vers = database.version;
					
					database.close();
					
					openDB(load, vers+1);
				}
			}
			
			openRequest.onerror = dberror;
			
			function checkStoreExistence(database, storeName) {
				for (var i=0;i<database.objectStoreNames.length;i++) {
					if (database.objectStoreNames[i] === storeName) {
						return true;
					}
				}
				return false;
			}
			
			function updateStore(database, storeName, data) {
				var trans = database.transaction(storeName, "readwrite");
				var objStore = trans.objectStore(storeName);
				
				var putRequest = objStore.put(data, 0);
				
				putRequest.onsuccess = function(e) {
					console.log("data successfully updated");
				}
				
				putRequest.onerror = dberror;
			}
			
			function loadStore(database, storeName) {
				var trans = database.transaction(storeName, "readonly");
				var objStore = trans.objectStore(storeName);
				
				var getRequest = objStore.get(0);
				
				getRequest.onsuccess = function(e) {
					console.log("loaded data");
					loadCurrentState2(e.target.result);
				}
				
				getRequest.onerror = dberror;
			}
			
			function dberror(e) {
				console.log(e.target.error);
			}
		}
		
		function imageToBlob(img) {
			// Create XHR
			var xhr = new XMLHttpRequest();
			
			var blob;

			xhr.open("GET", img.src, true);
			// Set the responseType to blob
			xhr.responseType = "blob";

			xhr.addEventListener("load", function () {
				if (xhr.status === 200) {
					console.log("Image retrieved");
					
					// File as response
					blob = xhr.response;

					// Put the received blob into IndexedDB
					
				}
			}, false);
			// Send XHR
			xhr.send();
		}
		
		function deleteDB() {
			var deleteRequest = indexedDB.deleteDatabase(databaseName);
			
			deleteRequest.onerror = function(e) {
				console.error("failed to delete database:", e.target.error);
			};
			
			deleteRequest.onsuccess = function(e) {
				console.log("database deleted");
			};
		}
		
		function newStoreName() {
			var dbRequest = indexedDB.open(databaseName);
			
			var string;
			
			dbRequest.onsuccess = function(e) {
				var db = e.target.result;
				
				var success = false;
				var i = 1;
				do {
					string = "untitled" + i;
					if (db.objectStoreNames.contains(string)) {
						i++;
					} else {
						success = true;
					}
				} while (success === false);
				
				currentStoreName = string;
			}
			
			
		}
		
		function loadProjectBrowser() {
			var browser = document.getElementById("existingBrowser");
			
			//First, add loading text
			//browser.innerHTML = "Loading...";
			
			//set up browser
			var maxWidth = parseFloat(window.getComputedStyle(browser).getPropertyValue('width'));
			
			var maxNum = Math.floor(maxWidth / 156);
			
			browser.innerHTML = "";
			while(browser.children.length>0) {
				browser.removeChild(browser.children[0]);
			}
			
			var tempRow = document.createElement("DIV");
			browser.appendChild(tempRow);
			var numInRow = 0;
			
			var numObjectStores;
			var requestsCompleted = 0;
			
			var openRequest = indexedDB.open(databaseName);
			
			openRequest.onupgradeneeded = function() {
				//??
			};
			
			openRequest.onsuccess = function(e) {
				var db = e.target.result;
				
				numObjectStores = db.objectStoreNames.length;
				for (var i=0;i<db.objectStoreNames.length;i++) {
					//iterate through each objectstore
					
					var storeName = db.objectStoreNames[i];
					
					var trans = db.transaction(storeName, "readonly");
					var objStore = trans.objectStore(storeName);
					
					var getRequest = objStore.get(0);
					
					getRequest.onsuccess = function(e) {
						if (!e.target.result) {
							return "";
						}
						addPreviewBox(e.target.result, e.target.source.name);
						requestsCompleted++;
						if (requestsCompleted === numObjectStores) {
							//completed
							db.close();
						}
					}
					
				}
			};
			
			openRequest.onerror = function() {
				console.error("ERROR");
			};
			
			function addPreviewBox(data, storeName) {
				//each column is 128px across
				
				//each box is 156 x 156
				//image preview is 128 x 128
				
				//create rows as long as there are images to load
				
				if (numInRow === maxNum) {
					tempRow = document.createElement("DIV");
					browser.appendChild(tempRow);
					numInRow = 0;
				}
				
				var projectBox = document.createElement("FIGURE");
				projectBox.className = "projectBox";
				projectBox.storeName = storeName;
				projectBox.data = data;
				
				var image = document.createElement("IMG");
				image.className = "previewProjectIcon";
				image.src = data.metadata.previewImage;
				//image
				
				var caption = document.createElement("FIGCAPTION");
				caption.innerHTML = data.metadata.name;
				caption.className = "projectCaption";
				
				projectBox.appendChild(image);
				projectBox.appendChild(caption);
				tempRow.appendChild(projectBox);
				
				projectBox.addEventListener("click", function(e) {
					
					//clear selectedImage first
					
					if (selectedProject) {
						selectedProject.style.backgroundColor = "#FFFFFF";
						selectedProject.children[1].style.color = "#000000";
					}
					
					this.style.backgroundColor = "#0022FF";
					this.children[1].style.color = "#FFFFFF";
					
					selectedProject = this;
				});
				
				projectBox.addEventListener("dblclick", function(e) {
					loadProject(this.data, this.storeName);
				});
				
				numInRow++;
				
			}
			
		}
		
		function loadProject(data, storeName) {
			currentStoreName = storeName;
			
			document.getElementById("startMenu").style.display = "none";
			
			loadCurrentState2(data);
			
			drawSceneOverview();
			drawProjectOverview();
			drawProperties();
		}
		
		function saveCurrentState() {
			var str = "";
			//use spaces to format everything
			//global var = gv
			for (var i=0;i<globalVariables.length;i++) {
				str += "gv " + globalVariables[i][0] + " " + globalVariables[i][1];
			}
			
			//scene = sc
			for (var i=0;i<scenes.length;i++) {
				str += "sc ";
				addProperties(scenes[i]);
			}
			
			
			//rect = re, circle = ci
			//text = te, script = sc
			//base = ba, shape = sh
			//ellipse = el
			//sprite = sp, 
			
			function addProperties(object) {
				
				//make sure only set necessary things
				var base = new object.constructor();
				for (var k in object) {
					if (base[k] !== object[k]) {
						if (k === "children") {
							if (object.children.length > 0) {
								console.log(object);
								//ch for children
								if (!object.isScene) {
									str += "ch ";
								}
								
								for (var l=0;l<object.children.length;l++) {
									var type;
									switch(object.children[l].constructor.name) {
										case "Rectangle":
											type = "re";
											break;
										case "Circle":
											type = "ci";
											break;
										case "Ellipse":
											type = "el";
											break;
										case "Text":
											type = "te";
											break;
										case "Script":
											type = "sc";
											break;
										case "Sprite":
											type = "sp";
											break;
										case "BaseObject":
											type = "ba";
											break;
										case "Shape":
											type = "sh";
											break;
									}
									str += type + " ";
									addProperties(object.children[l]);
									
								}
								console.log(object.children, base.children, object.children == base.children);
								if (!object.isScene) {
									str += "up ";
								}
							}
							
						} else if (k === "url") {
							
							//exportDoc += name + ".setImage('" + getBase64Image(object.image) + "');\n";
						} else if (k === "scripts") {

						} else if (k !== "parent" && k !== "loaded") {
							str += k + " " + object[k] + " ";
						}
					}
				}
			}
			return str;
		}
		
		function resetCurrent() {
			for (var i=0;i<scenes.length;i++) {
				delete scenes[i];
			}
			scenes = [];
			activeScene = null;
			objects = [];
			for (var i=0;i<objects.length;i++) {
				delete objects[i];
			}
			selectedObject = null;
		}
		
		/*
			Functions that change the layout of the page
		*/
		
		document.getElementById('sceneButton').addEventListener('click', showScene);
		
		function showScene() {
			document.getElementById('sceneOverview').style.display = "block";
			document.getElementById('projectOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "none";
		}
		
		document.getElementById('projectButton').addEventListener('click', showProject);
		
		function showProject() {
			document.getElementById('projectOverview').style.display = "block";
			document.getElementById('sceneOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "none";
		}
		
		document.getElementById('variablesButton').addEventListener('click', showVariables);
		
		function showVariables() {
			document.getElementById('projectOverview').style.display = "none";
			document.getElementById('sceneOverview').style.display = "none";
			document.getElementById('variableOverview').style.display = "block";
		}
		
		document.getElementById('detachButton').addEventListener('click', detachTextEditor);
		
		function detachTextEditor() {
			var myStyleSheet;
			
			//var screenWidth = screen.width, screenHeight = screen.height;
			var editorSize = window.getComputedStyle(textEditor);
			var editorWidth = editorSize.getPropertyValue("width");
			var editorHeight = editorSize.getPropertyValue("height");
			
			var editorPos = textEditor.getBoundingClientRect();
			// these are relative to the viewport, i.e. the window
			var editorTop = editorPos.top;
			var editorLeft = editorPos.left;
			
			var detachButton = document.getElementById('detachButton');
			detachButton.innerHTML = "reattach";
			detachButton.onclick = reattachTextEditor;
			
			newWindow = window.open("", "textEditWindow", "width=" + editorWidth + ", height=" + editorHeight + ", left=" + editorLeft + ", top=" + editorTop + ", location=no");
			newWindow.document.body.append(textEditor);
			newWindow.window.addEventListener('unload', function() {
				reattachTextEditor(newWindow);
			});
			newWindow.document.title = "Text Editor";
			
			window.onunload = function() {
				newWindow.close();
			};
			
			myStyleSheet = document.createElement('style');
			myStyleSheet.appendChild(document.createTextNode(""));
			myStyleSheet.type = "text/css";
			
			myStyleSheet.innerHTML = (`#textArea { width: 100%;
			height: 93%; resize: none; font-size: 16px;
			word-break: break-all; overflow: visible; white-space: pre-wrap;}
			* { margin: 0; border: 0; padding: 0; overflow: hidden; box-sizing: border-box;}
			button {background-color: buttonface; font-size: 20px; padding: 10px;}
			#textToolbar { width: 100%; height: 7%; border-top: 2px solid black;
			position: relative; bottom: 5px; }`);
			
			newWindow.document.head.appendChild(myStyleSheet);
			
			/*var toolbar = document.getElementById('textToolbar');
			toolbar.parentElement.removeChild(toolbar);
			newWindow.document.body.appendChild(toolbar);*/
		}
		
		function reattachTextEditor() {
			
			var viewport = document.getElementById("viewport");
			
			var main = document.getElementById("main");
			main.insertBefore(textEditor, viewport.nextSibling);
			
			var detachButton = document.getElementById('detachButton');
			detachButton.innerHTML = "detach";
			detachButton.onclick = detachTextEditor;
			
			newWindow.close();
		}
		
		document.getElementById('fullScreen').addEventListener('click', changeFullscreen);
		
		function changeFullscreen() {
			var bg = document.getElementById("viewport");
			
			bg.onwebkitfullscreenchange = function() {
				if (!fullscreen) {
					bg.style.width = "100vw";
					bg.style.height = "100vh";
					document.getElementById("fullScreen").innerHTML = "minimise";
					
					textEditor.style.display = "block"
				} else {
					bg.style.width = "70%";
					bg.style.height = "100%";
					document.getElementById("fullScreen").innerHTML = "fullscreen";
					
					textEditor.style.display = "inline-block";
				}
				
				fullscreen = !fullscreen;
			};
			
			bg.onwebkitfullscreenerror = function(){
				console.log("Full screen failed");
			};
			
			if (!fullscreen) {
				bg.webkitRequestFullscreen();
			} else {
				document.webkitExitFullscreen();
			}
		}
		
		document.getElementById('increaseSizeButton').addEventListener('click', increaseFontSize);
		
		function increaseFontSize() {
			changeFontSize(1);
		}
		
		document.getElementById('decreaseSizeButton').addEventListener('click', decreaseFontSize);
		
		function decreaseFontSize() {
			changeFontSize(-1);
		}
		
		function changeFontSize(amount) {
			var fontSize = parseFloat(window.getComputedStyle(textArea).getPropertyValue('font-size'));
			textArea.style.fontSize = fontSize + amount + 'px';
		}
		
		document.getElementById('play').addEventListener('click', play);
		
		function play() {
			if (menusDisabled === false) {
				overlayCanvas.style.display = "none";
				running = true;
				disableMenus();
				S7.clear();
				
				for (var i=0;i<globalVariables.length;i++) {
					window[globalVariables[i][0]] = globalVariables[i][1];
				}
				
				var newScenes = [];
				
				for (var i=0;i<scenes.length;i++) {
					newScenes.push(scenes[i].clone());
				}
				
				for (var i=0;i<newScenes.length;i++) {
					makeGlobalVar(newScenes[i]);
				}
				
				S7.run(newScenes[0]);
				
			}
			if (paused === true) {
				S7.run();
				running = true;
				paused = false;
			}
			
			function makeGlobalVar(obj) {
				window[obj.name] = obj;
				for (var j=0;j<obj.children.length;j++) {
					makeGlobalVar(obj.children[j]);
				}
			}
		}
		
		document.getElementById('pause').addEventListener('click', pause);
		
		function pause() {
			if (running === true) {
				S7.pause();
				paused = true;
				running = false;
			}
		}
		
		document.getElementById('stop').addEventListener('click', stop);
		
		function stop() {
			S7.stop();
			overlayCanvas.style.display = "block";
			paused = false;
			running = false;
			drawScene();
			enableMenus();
		}
		
		function isLegalVariable(name) {
			
			if (/[^a-zA-Z0-9_]|^[0-9]/.test(name)) {
				return false;
			}
			
			for (var i=0;i<objects.length;i++) {
				if (name === objects[i].name) {
					return false;
				}
			}
			
			//check reserved words?
			
			return true;
		}
		
		function updateCode() {
			//change number for index of script
			var value = scriptElement.value;
			selectedObject.updateScript(value, textArea.value);
		}
		
		document.getElementById('addScriptButton').addEventListener('click', createScript);
		
		function createScript() {
			textArea.value = "";//default script
			selectedObject.addScript(textArea.value);
			addScriptOption(selectedObject.scripts[selectedObject.scripts.length - 1]);
			textArea.readOnly = false;
		}
		
		function addScriptOption(script) {
			var temp = document.createElement("OPTION");
			temp.value = script.index;
			temp.innerHTML = script.name;
			scriptElement.appendChild(temp);
		}
		
		document.getElementById('scriptSelect').addEventListener('change', scriptChange);
		
		function scriptChange() {
			var value = scriptElement.value;
			if (!selectedObject) {
				textArea.value = "No object selected";
				textArea.readOnly = true;
				return "";
			}
			if (selectedObject.scripts[value] !== undefined) {
				textArea.value = selectedObject.scripts[value].code;
				textArea.readOnly = false;
			} else {
				textArea.value = "This object has no scripts";
				textArea.readOnly = true;
			}
		}
		
		function disableMenus() {
			menusDisabled = true;
			
			var properties = document.getElementsByClassName("properties");
			for (var i=0;i<properties.length;i++) {
				properties[i].readOnly = true;
				properties[i].disabled = true;
			}
			
			var sceneChildren = document.getElementsByClassName("sceneChild");
			for (var i=0;i<sceneChildren.length;i++) {
				sceneChildren[i].draggable = false;
			}
			
			textArea.readOnly = true;
			textArea.disabled = true;
			
		}
		
		function enableMenus() {
			menusDisabled = false;
			
			var properties = document.getElementsByClassName("properties");
			for (var i=0;i<properties.length;i++) {
				properties[i].readOnly = false;
				properties[i].disabled = false;
			}
			
			var sceneChildren = document.getElementsByClassName("sceneChild");
			for (var i=0;i<sceneChildren.length;i++) {
				sceneChildren[i].draggable = true;
			}
			
			textArea.readOnly = false;
			textArea.disabled = false;
		}
		
		window.onload = function() {
			//disableMenus();
			scriptChange();
		}
		
		document.getElementById('exportButton').addEventListener('click', showExportMenu);
		
		function showExportMenu() {
			document.getElementById("exportMenu").style.display = "block";
			disableMenus();
		}
		
		document.getElementById('exportBackArrow').addEventListener('click', hideExportMenu);
		
		function hideExportMenu() {
			document.getElementById("exportMenu").style.display = "none";
			enableMenus();
		}
		
		document.getElementById('newButton').addEventListener('click', showNewProject);
		
		function showNewProject() {
			document.getElementById("startMenu").style.display = "none";
			document.getElementById("newMenu").style.display = "block";
		}
		
		document.getElementById('backArrow').addEventListener('click', showStartMenu);
		
		function showStartMenu() {
			document.getElementById("newMenu").style.display = "none";
			document.getElementById("startMenu").style.display = "block";
			
			loadProjectBrowser();
		}
		
		})();
		
	</script>
	
</body>
</html>